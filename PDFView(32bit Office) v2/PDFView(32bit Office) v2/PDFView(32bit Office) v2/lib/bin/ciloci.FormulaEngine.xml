<?xml version="1.0"?>
<doc>
<assembly>
<name>
ciloci.FormulaEngine
</name>
</assembly>
<members>
<member name="T:ciloci.FormulaEngine.BuiltinFunctions">
	<summary>
 Implements all the functions that come standard with the formula engine
 </summary>
</member><member name="M:ciloci.FormulaEngine.DependencyManager.DependencyMap.CloneSourceDependents(System.Collections.IList,ciloci.FormulaEngine.DependencyManager.DependencyMap,ciloci.FormulaEngine.DependencyManager.DependencyMap)">
	<summary>
 Copy a portion of our dependencies into another DependencyMap
 </summary>
</member><member name="T:ciloci.FormulaEngine.DependencyManager.DependencyMap">
	<summary>
 A data structure to store a reference and a list of its dependents
 </summary>
</member><member name="M:ciloci.FormulaEngine.DependencyManager.AddFormula(ciloci.FormulaEngine.Formula)">
	<summary>
 Add all dependencies of a formula
 </summary>
</member><member name="M:ciloci.FormulaEngine.DependencyManager.RemoveFormula(ciloci.FormulaEngine.Formula)">
	<summary>
 Remove all dependencies of a formula
 </summary>
</member><member name="M:ciloci.FormulaEngine.DependencyManager.ProcessRangeLinks(ciloci.FormulaEngine.DependencyManager.IntersectingDependantProcessor)">
	<summary>
 Creates or removes range links
 </summary>
	<remarks>
 A range link is an optimization for dependencies involving ranges.  Given a reference to a range, we find
 all non-range references that intersect it.  We then create dependencies (or links) between those references and
 all depedendents of the target range.  If we didn't do this, then when walking a dependency chain, we'd have
 to find all intersecting references for each reference along the chain.
 </remarks>
</member><member name="M:ciloci.FormulaEngine.DependencyManager.GetCalculationList(System.Collections.IList)">
	<summary>
 Gets a sorted list of all references that depend on a given set of references
 </summary>
</member><member name="M:ciloci.FormulaEngine.DependencyManager.AddVolatileReference(System.Collections.IList)">
	<summary>
 Add any volatile functions to the roots of a calculation list
 </summary>
</member><member name="M:ciloci.FormulaEngine.DependencyManager.TopologicalSort(ciloci.FormulaEngine.DependencyManager.DependencyMap,ciloci.FormulaEngine.DependencyManager.DependencyMap,System.Collections.IList)">
	<summary>
 Perform the topological sort algorithm on our graph
 </summary>
</member><member name="M:ciloci.FormulaEngine.DependencyManager.IsSource(ciloci.FormulaEngine.Reference)">
	<summary>
 Determines if a reference is a source.  A source is a reference that only has dependents and no precedents
 </summary>
</member><member name="T:ciloci.FormulaEngine.DependencyManager">
	<summary>
 Manages formula dependencies
 </summary>
</member><member name="T:ciloci.FormulaEngine.ExcelParser.SynteticPatterns">
	<summary>An enumeration with the generated production node
identity constants.</summary>
</member><member name="M:ciloci.FormulaEngine.ExcelParser.#ctor(System.IO.TextReader)">
	<summary>Creates a new parser.</summary>
	<param name="input">the input stream to read from</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParserCreationException">if the parser
couldn't be initialized correctly</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelParser.#ctor(System.IO.TextReader,PerCederberg.Grammatica.Runtime.Analyzer)">
	<summary>Creates a new parser.</summary>
	<param name="input">the input stream to read from</param>
	<param name="analyzer">the analyzer to parse with</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParserCreationException">if the parser
couldn't be initialized correctly</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelParser.CreatePatterns">
	<summary>Initializes the parser by creating all the production
patterns.</summary>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParserCreationException">if the parser
couldn't be initialized correctly</exception>
</member><member name="T:ciloci.FormulaEngine.ExcelParser">
	<remarks>A token stream parser.</remarks>
</member><member name="E:ciloci.FormulaEngine.FormulaEngine.CircularReferenceDetected">
	<summary>Notifies listeners that the engine has detected one or more circular references</summary>
	<param name="sender">An instance of the formula engine</param>
	<param name="e">Information about the circular references</param>
	<remarks>This event will get fired when the engine detects one or more circular references.  Circular references are allowed
 by the engine but will be ignored during any recalculations.  You would typically listen to this event when you want
 to notify users that they have caused a circular reference.</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.CreateFormula(System.String)">
	<summary>
 Creates a formula by parsing an expression
 </summary>
	<param name="expression">The expression to parse</param>
	<returns>A formula representing the parsed expression</returns>
	<remarks>Works the same way as <see cref="M:ciloci.FormulaEngine.FormulaEngine.CreateFormula(System.String,ciloci.FormulaEngine.GrammarType)"/>
 except that the Excel grammar is used.</remarks>
	<exception cref="T:ciloci.FormulaEngine.InvalidFormulaException">The formula could not be created</exception>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.CreateFormula(System.String,ciloci.FormulaEngine.GrammarType)">
	<summary>
 Creates a formula by parsing an expression using a specific grammar
 </summary>
	<param name="expression">The expression to parse</param>
	<param name="gt">The type of grammar to use when parsing the expression</param>
	<returns>A formula representing the parsed expression</returns>
	<remarks>This method is used to create instances of the formula class from an expression.  The returned instance is
 not part of the formula engine; you must explicitly add it.</remarks>
	<exception cref="T:ciloci.FormulaEngine.InvalidFormulaException">The formula could not be created</exception>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.Evaluate(System.String)">
	<overloads>Evaluates an expression</overloads>
	<summary>
 Evaluates an expression using the Excel grammar
 </summary>
	<param name="expression">The expression to evaluate</param>
	<returns>The result of evaluating the expression</returns>
	<remarks>Works the same way as <see cref="M:ciloci.FormulaEngine.FormulaEngine.Evaluate(System.String,ciloci.FormulaEngine.GrammarType)"/> except that the Excel grammar
 is used.</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.Evaluate(System.String,ciloci.FormulaEngine.GrammarType)">
	<summary>
 Evaluates an expression after parsing it using a specific grammar
 </summary>
	<param name="expression">The expression to evaluate</param>
	<param name="gt">The type of grammar to use when parsing the expression</param>
	<returns>The result of evaluating the expression</returns>
	<remarks>You can use this function to evaluate an expression without creating a formula.  If you plan on evaluating the same
 expression many times, it is more efficient to create a formula from it first and then call its 
 <see cref="M:ciloci.FormulaEngine.Formula.Evaluate"/> method as many times as you need.</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.AddFormula(System.String,ciloci.FormulaEngine.IReference)">
	<overloads>Adds a formula to the engine</overloads>
	<summary>
 Adds a formula parsed from an expression into the engine
 </summary>
	<param name="expression">The expression to create the formula from</param>
	<param name="ref">The reference the formula will be bound to</param>
	<returns>The added formula</returns>
	<remarks>This method does the same thing as 
 <see cref="M:ciloci.FormulaEngine.FormulaEngine.AddFormula(ciloci.FormulaEngine.Formula,ciloci.FormulaEngine.IReference)"/>
 except that takes an expression instead of a formula.</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.AddFormula(ciloci.FormulaEngine.Formula,ciloci.FormulaEngine.IReference)">
	<summary>
 Adds a formula to the formula engine
 </summary>
	<param name="target">The formula instance to add</param>
	<param name="ref">The reference the formula will be bound to</param>
	<remarks>Use this method when you want to add a formula to the engine.  The engine will bind the formula to the given reference 
 and analyze its dependencies.  Currently, formulas can only be bound to cell, named, and external references.</remarks>
	<exception cref="T:System.ArgumentException">
		<list type="bullet">
			<item>The given formula was not created by this engine</item>
			<item>The formula cannot be bound to the type of reference given</item>
			<item>There is already a formula bound to the given reference</item>
		</list>
	</exception>
	<exception cref="T:System.ArgumentNullException">target or ref is null</exception>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.RemoveFormula(ciloci.FormulaEngine.Formula)">
	<summary>
 Removes a formula from the engine
 </summary>
	<param name="target">The formula instance to remove</param>
	<remarks>This method removes a formula from the engine and removes the formula's references from its dependency graph.</remarks>
	<exception cref="T:System.ArgumentException">
		<list type="bullet">
			<item>The given formula was not created by this engine</item>
			<item>The formula is not contained in the engine</item>
		</list>
	</exception>
	<exception cref="T:System.ArgumentNullException">The given formula is null</exception>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.CopySheetFormula(ciloci.FormulaEngine.Formula,ciloci.FormulaEngine.ISheetReference)">
	<summary>
 Copies and adjusts a formula on a sheet
 </summary>
	<param name="source">The formula to copy</param>
	<param name="destRef">The destination of the copied formula</param>
	<remarks>This method is used when wishing to implement copying of formulas similarly to Excel.  It makes a copy of the source formula, 
 offsets its references by the difference between destRef and source's current location, and adds the copy to the engine.
 The engine will only adjust references marked as relative in the copied formula.</remarks>
	<exception cref="T:System.ArgumentException">The source formula is not bound to a sheet reference</exception>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.SetFormulaDependencyReferences(ciloci.FormulaEngine.Formula)">
	<summary>
 Set the dependency references of a formula to their pooled equivalents
 </summary>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.Recalculate(ciloci.FormulaEngine.IReference)">
	<summary>
 Recalculates all formulas that depend on a reference
 </summary>
	<param name="root">The reference whose dependents will be recalculated</param>
	<remarks>This is the method that controls all recalculation in the formula engine.  Given a root reference, it will find
 all formulas that depend on it and recalculate them in natural order.  If no formulas depend on the given reference then the 
 method does nothing.</remarks>
	<example>This example demonstrates how to define some formulas and then have the engine recalculate them
 <code>
 Dim engine As New FormulaEngine
 ' Add a formula at B2 that depends on cell A1
 engine.AddFormula("a1+1", engine.ReferenceFactory.Parse("B2"))
 ' Add a formula at C3 that depends on the formula at cell B2
 engine.AddFormula("b2+1", engine.ReferenceFactory.Parse("c3"))
 ' Get a reference to cell A1
 Dim a1Ref As ISheetReference = engine.ReferenceFactory.Parse("A1")
 ' This will recalculate the formula at B2, then the formula at C3
 engine.Recalculate(a1Ref)
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.HasFormulaAt(ciloci.FormulaEngine.IReference)">
	<summary>
 Determines if the engine has a formula bound to a particular reference
 </summary>
	<param name="ref">The reference to test</param>
	<returns>True is there is a formula bound to the reference; False if there is not</returns>
	<remarks>Use this formula to test if the engine has a formula bound to a given reference</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.GetFormulaAt(ciloci.FormulaEngine.IReference)">
	<summary>
 Gets the formula bound to a particular reference
 </summary>
	<param name="ref">The reference to find a formula for</param>
	<returns>The formula bound to the reference; null if no formula is bound to ref</returns>
	<remarks>Use this method when you have a reference and need to get the formula that is bound to it</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.RemoveFormulaAt(ciloci.FormulaEngine.IReference)">
	<summary>
 Removes a formula bound to a particular reference
 </summary>
	<param name="ref">The reference whose formula to remove</param>
	<remarks>This method will remove the formula bound to a particular reference</remarks>
	<exception cref="T:System.ArgumentException">No formula is bound to ref</exception>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.RemoveFormulasInRange(ciloci.FormulaEngine.ISheetReference)">
	<summary>
 Removes all sheet formulas in a given range
 </summary>
	<param name="range">The range to clear formulas in</param>
	<remarks>This method is used when you need to clear all sheet formulas in a given range.  All formulas bound to references
 on the same sheet as range and that intersect its area will be removed from the engine.</remarks>
	<example>This sample shows how to remove all formulas in the range B2:C4
 <code>
 Dim engine As New FormulaEngine
 ' Declare a reference to all cells from B2 to C4
 Dim range As ISheetReference = engine.ReferenceFactory.Parse("B2:C4")
 ' Remove all formulas in that range
 engine.RemoveFormulasInRange(range)
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.RemoveFormulas(System.Collections.IList)">
	<summary>
 Remove many formulas in a more efficient manner
 </summary>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.Clear">
	<summary>
 Resets the formula engine to an empty state
 </summary>
	<remarks>Use this function when you need to reset the formula engine to an empty state.  This function will remove all: formulas, dependencies, 
 references, and sheets from the engine.  It will <b>not</b> clear the function library.  You should call that class'
 <see cref="M:ciloci.FormulaEngine.FunctionLibrary.Clear(System.Boolean)"/> method if you also want to remove all formulas.</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.OnColumnsInserted(System.Int32,System.Int32)">
	<summary>
 Notifies the engine that columns have been inserted on the active sheet
 </summary>
	<param name="insertAt">The index of the first inserted column</param>
	<param name="count">The number of columns inserted</param>
	<remarks>Use this method to notify the engine that columns have been inserted on the active sheet.  The engine will update
 all references as necessary.</remarks>
	<exception cref="T:System.ArgumentOutOfRangeException">
		<list type="bullet">
			<item>insertAt is less than 1</item>
			<item>count is negative</item>
		</list>
	</exception>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.OnColumnsRemoved(System.Int32,System.Int32)">
	<summary>
 Notifies the engine that columns have been removed on the active sheet
 </summary>
	<param name="removeAt">The index of the first removed column</param>
	<param name="count">The number of removed columns</param>
	<remarks>Use this method to notify the engine that columns have been removed on the active sheet.  The engine will invalidate
 all references in the removed area, recalculate any formulas that depend on those references, and remove all
 formulas in the area.</remarks>
	<exception cref="T:System.ArgumentOutOfRangeException">
		<list type="bullet">
			<item>removeAt is less than 1</item>
			<item>count is negative</item>
		</list>
	</exception>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.OnRowsInserted(System.Int32,System.Int32)">
	<summary>
 Notifies the engine that rows have been inserted on the active sheet
 </summary>
	<param name="insertAt">The index of the first inserted row</param>
	<param name="count">The number of rows inserted</param>
	<remarks>Use this method to notify the engine that rows have been inserted on the active sheet.  The engine will update
 all references as necessary.</remarks>
	<exception cref="T:System.ArgumentOutOfRangeException">
		<list type="bullet">
			<item>insertAt is less than 1</item>
			<item>count is negative</item>
		</list>
	</exception>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.OnRowsRemoved(System.Int32,System.Int32)">
	<summary>
 Notifies the engine that rows have been removed on the active sheet
 </summary>
	<param name="removeAt">The index of the first removed row</param>
	<param name="count">The number of removed rows</param>
	<remarks>Use this method to notify the engine that rows have been removed on the active sheet.  The engine will invalidate
 all references in the removed area, recalculate any formulas that depend on those references, and remove all
 formulas in the area.</remarks>
	<exception cref="T:System.ArgumentOutOfRangeException">
		<list type="bullet">
			<item>removeAt is less than 1</item>
			<item>count is negative</item>
		</list>
	</exception>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.OnRangeMoved(ciloci.FormulaEngine.ISheetReference,System.Int32,System.Int32)">
	<summary>
 Notifies the engine that a range has moved
 </summary>
	<param name="range">The range that has moved</param>
	<param name="rowOffset">The number of rows range has moved.  Can be negative.</param>
	<param name="colOffset">The number of columns the range has moved.  Can be negative.</param>
	<remarks>Use this method to notify the engine that a range on a sheet has moved.  The engine will update all references
 in, or that depend on, the moved range accordingly.</remarks>
	<exception cref="T:System.ArgumentOutOfRangeException">The given range, when offset by the given offsets, is not within the bounds
 of the active sheet</exception>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.CreateError(ciloci.FormulaEngine.ErrorValueType)">
	<summary>
 Creates an error wrapper around a specified error type
 </summary>
	<param name="errorType">The type of error to create a wrapper for</param>
	<returns>A wrapper around the error</returns>
	<remarks>This function lets you create an error wrapper around a specific error type</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.GetNamedReferences">
	<summary>
 Gets all named references bound to formulas in the engine
 </summary>
	<returns>An array of named references</returns>
	<remarks>Use this function when you need to get all the named references bound to formulas in this engine.</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.DefineVariable(System.String)">
	<summary>
 Defines a variable for use in formulas
 </summary>
	<param name="name">The name of the variable</param>
	<returns>A <see cref="T:ciloci.FormulaEngine.Variable"/> instance representing the newly defined variable</returns>
	<remarks>Use this method to define a new variable for use in formulas</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngine.RecreateParsers">
	<summary>
 Recreates the parsers used to parse formulas
 </summary>
	<remarks>The parsers used to parse formulas are cached to improve performance.  Calling this method will
 force the creation of a new instance of the parser.  You typically will not need to
 call this method unless you are switching cultures at run-time.</remarks>
</member><member name="P:ciloci.FormulaEngine.FormulaEngine.FunctionLibrary">
	<summary>
 Gets the function library the engine is using
 </summary>
	<value>An instance of FunctionLibrary</value>
	<remarks>This property lets you access the engine's function library</remarks>
</member><member name="P:ciloci.FormulaEngine.FormulaEngine.FormulaCount">
	<summary>
 Gets the number of formulas this engine contains
 </summary>
	<value>A count of all the formulas</value>
	<remarks>Use this property when you need to know how many formulas are contained in the engine</remarks>
</member><member name="P:ciloci.FormulaEngine.FormulaEngine.ReferenceFactory">
	<summary>Gets the engine's ReferenceFactory instance</summary>
	<value>The reference factory of the engine</value>
	<remarks>This property lets you access this engine's reference factory</remarks>
</member><member name="P:ciloci.FormulaEngine.FormulaEngine.Sheets">
	<summary>Gets the engine's SheetCollection instance</summary>
	<value>The SheetCollection of engine</value>
	<remarks>Use this property when you need to access the engine's SheetCollection</remarks>
</member><member name="P:ciloci.FormulaEngine.FormulaEngine.Info">
	<summary>
 Gets the engine's FormulaEngineInfo instance
 </summary>
	<value>An instance of the FormulaEngineInfo class</value>
	<remarks>This property lets you access the engine's FormulaEngineInfo instance</remarks>
</member><member name="T:ciloci.FormulaEngine.FormulaEngine">
	<summary>
 Implements all the functionality of a formula engine
 </summary>
	<remarks>This is the main class of this library.  It is responsible for managing formulas, their dependencies, and
 all recalculations.  You can think of this class as a container for formulas.  It has methods for adding and removing formulas and
 methods for recalculating all formulas that depend on a given reference.</remarks>
	<example>This example shows how you can declare a formula that points to a cell and have the formula engine recalculate it
 when you tell it that the cell has changed:
 <code>
 Dim engine As New FormulaEngine
 ' Declare a reference to cell B2
 Dim b2Ref As ISheetReference = engine.ReferenceFactory.Parse("B2")
 ' Add a formula that depends on cell A1 at cell B2
 engine.AddFormula("A1+1", b2Ref)
 ' Declare a reference to cell A1
 Dim a1Ref As ISheetReference = engine.ReferenceFactory.Parse("A1")
 ' Tell the engine that cell A1 has changed at which point it will recalculate the formula at B2
 engine.Recalculate(a1Ref)
 ' Remove the formula at B2
 engine.RemoveFormulaAt(b2Ref)
 </code>
	</example>
</member><member name="T:ciloci.FormulaEngine.OperandFactory">
	<summary>
 Creates an operand dynamically based on a value
 </summary>
</member><member name="M:ciloci.FormulaEngine.FormulaEngineInfo.GetCalculationList(ciloci.FormulaEngine.IReference)">
	<summary>
 Gets the calculation list for a reference
 </summary>
	<param name="root">The reference from where to calculate the list</param>
	<returns>An array of formulas that would need to be recalculated</returns>
	<remarks>Given a reference, this method returns a list of formulas that would need to be recalculated when that reference changes.
 The formulas in the list will be in natural order.</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngineInfo.IsReferenceValid(ciloci.FormulaEngine.IReference)">
	<summary>
 Determines whether a reference is valid
 </summary>
	<param name="ref">The reference to check</param>
	<returns>True if the reference is valid; False if it is not</returns>
	<remarks>This function determines whether a given reference is valid.  For example: A reference to column C will become
 invalid when column C is removed.</remarks>
</member><member name="M:ciloci.FormulaEngine.FormulaEngineInfo.GetDirectPrecedentsCount(ciloci.FormulaEngine.IReference)">
	<summary>
 Gets the number of direct precedents of a reference
 </summary>
	<param name="ref">The reference whose direct precedents to get</param>
	<returns>A count of the number of direct precedents of the reference</returns>
	<remarks>The count indicates the number of references that have ref as their dependant</remarks>
</member><member name="P:ciloci.FormulaEngine.FormulaEngineInfo.ReferenceCount">
	<summary>
 Gets the total number of references tracked by the engine
 </summary>
	<value>A count indicating the total number of references</value>
	<remarks>This property lets you get a count of the total number of references that the engine is tracking</remarks>
</member><member name="P:ciloci.FormulaEngine.FormulaEngineInfo.DependentsCount">
	<summary>
 Gets the number of dependents in the engine's dependency graph
 </summary>
	<value>A count of the number of dependents</value>
	<remarks>The count indicates the number of references that have other references which depend on them</remarks>
</member><member name="P:ciloci.FormulaEngine.FormulaEngineInfo.PrecedentsCount">
	<summary>
 Gets the number of precedents in the engine's dependency graph
 </summary>
	<value>A count of the number of precedents</value>
	<remarks>The count indicates the number of references that are dependents of other references</remarks>
</member><member name="P:ciloci.FormulaEngine.FormulaEngineInfo.DependencyDump">
	<summary>
 Gets a string representation of the engine's dependency graph
 </summary>
	<value>A string representing all dependencies</value>
	<remarks>This property will return a string representation of the engine's dependents graph.  There will be one
 line for each dependency and each line will be of the form "Ref1 -&gt; Ref2, Ref3" and reads that a change in Ref1 will 
 change Ref2 and Ref3.</remarks>
</member><member name="T:ciloci.FormulaEngine.FormulaEngineInfo">
	<summary>
 Contains useful information about the formula engine
 </summary>
	<remarks>This class allows you to get various information about the formula engine.  Mostly used for development/testing and when
 you would like to show some statistics to the user.</remarks>
</member><member name="M:ciloci.FormulaEngine.GridOperationsBase.HandleRangeMoved(ciloci.FormulaEngine.SheetReference,ciloci.FormulaEngine.SheetReference,ciloci.FormulaEngine.SheetReference,ciloci.FormulaEngine.GridOperationsBase.SetRangeCallback)">
	<summary>
 Handles a range move and tries to do it the same way as Excel.  This function is way too complicated but Excel has some very
 weird rules with regards to range moves and this is the only way I can think of emulating them.
 </summary>
</member><member name="T:ciloci.FormulaEngine.GridOperationsBase">
	<summary>
 Encapsulates all grid related operations on a reference.  I made this a separate class so that non-grid references don't have
 to include all these methods as stubs.
 </summary>
</member><member name="T:ciloci.FormulaEngine.NullGridOps">
	<summary>
 Returned by references that don't interact with the grid
 </summary>
</member><member name="M:ciloci.FormulaEngine.Utility.Parse(System.String)">
	<summary>
 Tries to convert a string into a value similarly to Excel
 </summary>
	<param name="text">The string to parse</param>
	<returns>A value from the parsed string</returns>
	<remarks>This method will try to parse text into a value.  It will try to convert the text into a Boolean, ErrorValueWrapper, 
 DateTime, Integer, Double, or if all of the previous conversions fail, a string.</remarks>
</member><member name="M:ciloci.FormulaEngine.Utility.IsNumericType(System.Type)">
	<summary>
 Determines whether a type is a numeric type
 </summary>
	<param name="t">The type to test</param>
	<returns>True if the type is numeric; False otherwise</returns>
	<remarks>Useful when you are processing sheet values and need to know that a type is numeric</remarks>
</member><member name="M:ciloci.FormulaEngine.Utility.IsNumericValue(System.Object)">
	<summary>
 Determines whether a value is of a numeric type
 </summary>
	<param name="value">The value to test</param>
	<returns>True if the value is numeric; False otherwise</returns>
	<remarks>This does the same thing as <see cref="M:ciloci.FormulaEngine.Utility.IsNumericType(System.Type)"/> except that it acts
 on a value.</remarks>
</member><member name="M:ciloci.FormulaEngine.Utility.NormalizeNumericValue(System.Object)">
	<summary>
 Converts a numeric value to a double
 </summary>
	<param name="value">The value to convert</param>
	<returns>The value converted to a double</returns>
	<remarks>Since there are many types of numeric values in .NET, there exists a need to have a common denominator format that
 they all can be converted to.  The type chosen here is the Double.</remarks>
	<exception cref="T:System.ArgumentException">The value is not of a numeric type</exception>
</member><member name="M:ciloci.FormulaEngine.Utility.NormalizeIfNumericValue(System.Object)">
	<summary>
 Normalizes a value if it is of a numeric type
 </summary>
	<param name="value">The value to try to normalize</param>
	<returns>The value normalized value</returns>
	<remarks>This function normalizes value if it is of a numeric type; otherwise it returns the value unchanged</remarks>
</member><member name="M:ciloci.FormulaEngine.Utility.Wildcard2Regex(System.String)">
	<summary>
 Gets the regular expression equivalent pattern of an excel wildcard expression
 </summary>
	<param name="pattern">The pattern to convert</param>
	<returns>A regular expression representation of pattern</returns>
	<remarks>Excel has its own syntax for pattern matching that many functions use.  This method converts such an expression
 into its regular expression equivalent.</remarks>
</member><member name="M:ciloci.FormulaEngine.Utility.IsRectangleInSheet(System.Drawing.Rectangle,ciloci.FormulaEngine.ISheet)">
	<summary>
 Determines whether a rectangle is inside the bounds of a given sheet
 </summary>
	<param name="rect">The rectangle to test</param>
	<param name="sheet">The sheet to use</param>
	<returns>True if the sheet contains the rectangle; False otherwise</returns>
	<remarks>Use this function when you have a rectangle and a sheet and need to know if the rectangle is inside the sheet's bounds.</remarks>
</member><member name="M:ciloci.FormulaEngine.Utility.GetTableRow(System.Object[0:,0:],System.Int32)">
	<summary>
 Gets a row from a table of values
 </summary>
	<param name="table">The table to get the row from</param>
	<param name="rowIndex">The index of the row to get</param>
	<returns>An array containing the values from the requested row</returns>
	<remarks>This method is used when you have a table of values (like the ones returned by <see cref="M:ciloci.FormulaEngine.ISheetReference.GetValuesTable"/>) 
 and you need to get the values from a row.</remarks>
</member><member name="M:ciloci.FormulaEngine.Utility.GetTableColumn(System.Object[0:,0:],System.Int32)">
	<summary>
 Gets a column from a table of values
 </summary>
	<param name="table">The table to get the column from</param>
	<param name="columnIndex">The index of the column to get</param>
	<returns>An array containing the values from the requested column</returns>
	<remarks>This method is used when you have a table of values (like the ones returned by <see cref="M:ciloci.FormulaEngine.ISheetReference.GetValuesTable"/>) 
 and you need to get the values from a column.</remarks>
</member><member name="M:ciloci.FormulaEngine.Utility.ColumnIndex2Label(System.Int32)">
	<summary>
 Gets the label for a column index
 </summary>
	<param name="columnIndex">The index whose label you wish to get</param>
	<returns>A string with the colum label</returns>
	<remarks>This function is handy when you have a column index and you want to get its associated label.</remarks>
	<example>
		<list type="table">
			<listheader><term>Column index</term><description>Resultant label</description></listheader>
			<item><term>1</term><description>"A"</description></item>
			<item><term>14</term><description>"N"</description></item>
			<item><term>123</term><description>"DS"</description></item>
			<item><term>256</term><description>"IV"</description></item>
		</list>
	</example>
</member><member name="M:ciloci.FormulaEngine.Utility.ColumnLabel2Index(System.String)">
	<summary>
 Gets the column index from a column label
 </summary>
	<param name="label">The label whose column index you wish to get</param>
	<returns>An index representing the label</returns>
	<remarks>This function is handy when you have a column label and you want to get its associated index.</remarks>
	<example>
		<list type="table">
			<listheader><term>Column label</term><description>Resultant index</description></listheader>
			<item><term>"A"</term><description>1</description></item>
			<item><term>"N"</term><description>14</description></item>
			<item><term>"DS"</term><description>123</description></item>
			<item><term>"IV"</term><description>256</description></item>
		</list>
	</example>
</member><member name="T:ciloci.FormulaEngine.Utility">
	<summary>
 Provides various utility functions
 </summary>
	<remarks>This class provides various methods for doing common tasks when dealing with formulas</remarks>
</member><member name="M:ciloci.FormulaEngine.Variable.Recalculate">
	<summary>
 Recalculates any formulas that depend on this variable
 </summary>
	<remarks>Call this method after you have changed the value of a variable and you want the formula engine
 to recalculate any dependant formulas.</remarks>
</member><member name="M:ciloci.FormulaEngine.Variable.Dispose">
	<summary>
 Undefines the variable
 </summary>
	<remarks>Call this method when you are finished using the variable and wish to remove it from the formula engine</remarks>
</member><member name="P:ciloci.FormulaEngine.Variable.Name">
	<summary>
 Gets the name of the variable
 </summary>
	<value>The variable's name</value>
	<remarks>Use this property to get the name of the variable</remarks>
</member><member name="P:ciloci.FormulaEngine.Variable.Value">
	<summary>
 Gets or sets the value of the variable
 </summary>
	<value>The value of the variable</value>
	<remarks>Use this property to get the value of the variable or to assign a new value to it.  Once a new value is assigned, 
 all formulas that reference it will use the new value once they are recalculated.</remarks>
</member><member name="T:ciloci.FormulaEngine.Variable">
	<summary>
 Represents a named value in a formula
 </summary>
	<remarks>This class encapsulates a named value that can be used in formulas.
 You define a variable using the <see cref="M:ciloci.FormulaEngine.FormulaEngine.DefineVariable(System.String)"/> method, set its value, and
 then reference it from other formulas.  Once you are finished with the variable, you call its Dispose method to remove it from
 the formula engine.</remarks>
	<example>This example shows how to define a variable, use it in a formula, and then undefine it:
 <code>
 Dim engine As New FormulaEngine
 ' Create a new variable called 'x'
 Dim v As Variable = engine.DefineVariable("x")
 ' Give it a value of 100
 v.Value = 100
 ' Create a formula that uses the variable
 Dim f As Formula = engine.CreateFormula("=x*cos(x)")
 ' Evaluate the formula to get a result
 Dim result As Object = f.Evaluate()
 ' Undefine the variable
 v.Dispose()
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.GeneralTokenizer.#ctor(System.IO.TextReader)">
	<summary>Creates a new tokenizer for the specified input
stream.</summary>
	<param name="input">the input stream to read</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParserCreationException">if the tokenizer
couldn't be initialized correctly</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralTokenizer.CreatePatterns">
	<summary>Initializes the tokenizer by creating all the token
patterns.</summary>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParserCreationException">if the tokenizer
couldn't be initialized correctly</exception>
</member><member name="T:ciloci.FormulaEngine.GeneralTokenizer">
	<remarks>A character stream tokenizer.</remarks>
</member><member name="F:ciloci.FormulaEngine.ErrorValueType.Div0">
	<summary>A division by zero was encountered</summary>
</member><member name="F:ciloci.FormulaEngine.ErrorValueType.Name">
	<summary>A formula referenced a name that is not defined</summary>
</member><member name="F:ciloci.FormulaEngine.ErrorValueType.NA">
	<summary>A result is not available</summary>
</member><member name="F:ciloci.FormulaEngine.ErrorValueType.Null">
	<summary>The two given sheet references do not intersect</summary>
</member><member name="F:ciloci.FormulaEngine.ErrorValueType.Num">
	<summary>A calculation is invalid for numerical reasons</summary>
</member><member name="F:ciloci.FormulaEngine.ErrorValueType.Ref">
	<summary>A reference is not valid</summary>
</member><member name="F:ciloci.FormulaEngine.ErrorValueType.Value">
	<summary>The given value is not valid</summary>
</member><member name="T:ciloci.FormulaEngine.ErrorValueType">
	<summary>
 Defines constants for all errors that a formula can generate during evaluation
 </summary>
	<remarks>Formulas that produce an error during calculation will produce an <see cref="T:ciloci.FormulaEngine.ErrorValueWrapper"/> around
 one of these values.  The values map directly to the values used by Excel.</remarks>
</member><member name="F:ciloci.FormulaEngine.OperandType.Double">
	<summary>A standard .NET Double</summary>
</member><member name="F:ciloci.FormulaEngine.OperandType.String">
	<summary>A standard .NET String</summary>
</member><member name="F:ciloci.FormulaEngine.OperandType.Boolean">
	<summary>A standard .NET Boolean</summary>
</member><member name="F:ciloci.FormulaEngine.OperandType.Reference">
	<summary>Any type of reference</summary>
</member><member name="F:ciloci.FormulaEngine.OperandType.SheetReference">
	<summary>A reference that points to cells on a sheet</summary>
</member><member name="F:ciloci.FormulaEngine.OperandType.Integer">
	<summary>A standard .NET Integer</summary>
</member><member name="F:ciloci.FormulaEngine.OperandType.Self">
	<summary>A conversion of an operand to itself</summary>
</member><member name="F:ciloci.FormulaEngine.OperandType.Primitive">
	<summary>Any data type except a reference</summary>
</member><member name="F:ciloci.FormulaEngine.OperandType.Error">
	<summary>An error value</summary>
</member><member name="F:ciloci.FormulaEngine.OperandType.Blank">
	<summary>A blank value</summary>
</member><member name="F:ciloci.FormulaEngine.OperandType.DateTime">
	<summary>A standard .NET DateTime</summary>
</member><member name="T:ciloci.FormulaEngine.OperandType">
	<summary>
 Defines constants to represent the data types of a formula function's arguments
 </summary>
	<remarks>These values are used when working with functions to specify the desired data type of an argument and to get its value</remarks>
</member><member name="T:ciloci.FormulaEngine.InvalidFormulaException">
	<summary>
 The exception that is thrown when attempting to create an invalid formula
 </summary>
	<remarks>
 This exception will be thrown when attempting to create a formula that is invalid.  The most common (though not the only) reason is that
 the syntax of the formula does not conform to the parser's grammar.  The inner exception will always be initialized and will
 contain the specifics as to why the formula could not be created.  
 </remarks>
</member><member name="M:ciloci.FormulaEngine.ISheet.GetCellValue(System.Int32,System.Int32)">
	<summary>
 Gets the value of a particular cell
 </summary>
	<param name="row">The row of the required cell.  First row is 1</param>
	<param name="column">The column of the required cell.  First column is 1</param>
	<returns>The value of the cell at row,col</returns>
	<remarks>The formula engine will call this method when the value of a cell is required.  Your implementation should
 lookup the cell at row,col and return its value</remarks>
</member><member name="M:ciloci.FormulaEngine.ISheet.SetFormulaResult(System.Object,System.Int32,System.Int32)">
	<summary>
 Stores the value of a formula into a cell
 </summary>
	<param name="result">The formula result that must be stored</param>
	<param name="row">The row of the required cell.  First row is 1</param>
	<param name="column">The column of the required cell.  First column is 1</param>
	<remarks>The formula engine will call this method when the result of a grid formula should be stored into the sheet.
 Your implementation should lookup the cell at row,col and store the result into it.</remarks>
</member><member name="P:ciloci.FormulaEngine.ISheet.Name">
	<summary>
 Gets the name of the worksheet
 </summary>
	<value>The name of the worksheet</value>
	<remarks>The name of a worksheet is used by the formula engine to find a sheet when its name is used in a reference.
 For example: When evaluating the formula "=Sheet3!A1 * 2", the formula engine will look through all sheets until
 it finds the one with the name "Sheet3".</remarks>
	<note>Sheet names are treated without regard to case</note>
</member><member name="P:ciloci.FormulaEngine.ISheet.RowCount">
	<summary>
 Gets number of rows in the sheet
 </summary>
	<value>The number of rows in the sheet</value>
	<remarks>This property is used by the engine to determine sheet bounds</remarks>
</member><member name="P:ciloci.FormulaEngine.ISheet.ColumnCount">
	<summary>
 Gets number of columns in the sheet
 </summary>
	<value>The number of columns in the sheet</value>
	<remarks>This property is used by the engine to determine sheet bounds</remarks>
</member><member name="T:ciloci.FormulaEngine.ISheet">
	<summary>
 Represents a worksheet as seen by the formula engine
 </summary>
	<remarks>This interface defines the contract that any class wishing to act as a worksheet must implement.  All interaction
 with cell values is done through this interface.</remarks>
</member><member name="E:ciloci.FormulaEngine.IReference.Recalculated">
	<summary>Signals that the reference's formula has been recalculated</summary>
	<remarks>You can listen to this event to be notified when the formula that is bound to this reference has been recalculated.</remarks>
</member><member name="M:ciloci.FormulaEngine.IReference.GetReferenceValues(ciloci.FormulaEngine.IReferenceValueProcessor)">
	<summary>Gets the values that the reference points to</summary>
	<param name="processor">A class responsible from processing the reference's values</param>
	<remarks>You should call this method when you need reference's values.  The reference will pass each of its values to the
 processor and it is up to that processor to store or use them to compute a result.</remarks>
</member><member name="M:ciloci.FormulaEngine.IReference.Equals(ciloci.FormulaEngine.IReference)">
	<summary>Determines whether this reference equals another</summary>
	<param name="ref">The reference to test against</param>
	<returns>True is the current reference is equal to ref.  False otherwise</returns>
	<remarks>This method exists mostly for testing purposes.</remarks>
</member><member name="M:ciloci.FormulaEngine.IReference.ToString">
	<summary>Returns a formatted representation of the reference</summary>
	<remarks>This method allows you to get a string representation of the reference</remarks>
</member><member name="T:ciloci.FormulaEngine.IReference">
	<summary>
 Represents a reference to a value or set of values
 </summary>
	<remarks>This is the base interface for all references.  A reference is simply a pointer to a value or formula.  
 All formulas that are managed by the formula engine must be associated with a reference.  
 You can change the context of a formula by binding it to different types of references.</remarks>
</member><member name="M:ciloci.FormulaEngine.ISheetReference.GetValuesTable">
	<summary>Returns a table of the reference's values</summary>
	<remarks>This function returns a table that represents the reference's values from its sheet.  The first dimension is the rows
 and the second dimension is columns.  This method is useful when you wish to do lookups on a sheet reference's values.</remarks>
</member><member name="P:ciloci.FormulaEngine.ISheetReference.Row">
	<summary>Gets row of the reference</summary>
	<remarks>The row of the reference on its sheet</remarks>
</member><member name="P:ciloci.FormulaEngine.ISheetReference.Column">
	<summary>Gets the column of the reference</summary>
	<remarks>The column of the reference on its sheet</remarks>
</member><member name="P:ciloci.FormulaEngine.ISheetReference.Height">
	<summary>Gets number of rows in the reference</summary>
	<remarks>The number of rows the reference spans on its sheet</remarks>
</member><member name="P:ciloci.FormulaEngine.ISheetReference.Width">
	<summary>Gets the number of columns in the reference</summary>
	<remarks>The number of columns the reference spans on its sheet</remarks>
</member><member name="P:ciloci.FormulaEngine.ISheetReference.Area">
	<summary>The reference's area as a rectangle</summary>
	<remarks>A convenience property for getting a reference's area as a rectangle</remarks>
</member><member name="P:ciloci.FormulaEngine.ISheetReference.Sheet">
	<summary>Gets the sheet that the reference is on</summary>
	<remarks>This property lets you access the sheet that the reference is on</remarks>
</member><member name="T:ciloci.FormulaEngine.ISheetReference">
	<summary>
 Represents a reference to cells on a sheet
 </summary>
	<remarks>Sheet references are the most common type of reference and consist of a sheet and an area on that sheet.  Any formula 
 that needs values from a sheet will use sheet references and all formulas that are on a sheet must be bound to them.</remarks>
</member><member name="P:ciloci.FormulaEngine.INamedReference.Name">
	<summary>
 Gets the name of the reference
 </summary>
	<value>The name of the reference</value>
	<remarks>This property lets you obtain the name of the reference</remarks>
</member><member name="P:ciloci.FormulaEngine.INamedReference.Result">
	<summary>Gets result of evaluating the reference's formula</summary>
	<value>The result of the reference's formula</value>
	<remarks>Use this property to get the result of evaluating this reference's formula</remarks>
</member><member name="T:ciloci.FormulaEngine.INamedReference">
	<summary>
 Represents a reference to a name
 </summary>
	<remarks>Named references allow you to associate a formula with a name.  By binding a formula to a named reference,
 you make it possible to use that formula's result in other formulas by simply typing the name.  This can make formulas cleaner and less complex since you can
 reuse a particular result in many formulas rather than duplicating the same expression in each one.  The formula engine will recalculate
 all formulas that depend on a name when the value of the formula bound to the name changes.</remarks>
	<example>This example shows how you can define a constant and use it in another formula:
 <code>
 Dim engine As New FormulaEngine
 ' Add a constant named InterestRate with a value of 0.15
 engine.AddFormula("=0.15", engine.ReferenceFactory.Named("InterestRate"))
 ' Use the constant in a formula
 Dim result As Object = engine.Evaluate("=1000 * InterestRate")
 </code>
	</example>
</member><member name="P:ciloci.FormulaEngine.IExternalReference.Result">
	<summary>Gets result of evaluating the reference's formula</summary>
	<value>The result of the reference's formula</value>
	<remarks>You typically will listen to the <see cref="E:ciloci.FormulaEngine.IExternalReference.Recalculated"/> event and when it fires you use this property in your handler to get the latest
 value of the reference's formula.</remarks>
</member><member name="T:ciloci.FormulaEngine.IExternalReference">
	<summary>
 Represents a reference outside of a sheet
 </summary>
	<remarks>External references are similar to named references in that you can use both without any sheets.  A limitation of named
 references is that each name must be unique.  This can make it difficult to define many non-sheet formulas because you have to
 generate a unique name for each one.  External references do not have this limitation and you can create as many as you need.  
 Their only drawback is that they cannot be referenced in formulas like named references.  This basically makes them only useful as
 bind targets for formulas.</remarks>
	<note>Since each instance of an external reference is unique, you must keep track of the instance you create because you will
 need to supply it when you wish to get the formula bound to it from the engine.</note>
</member><member name="M:ciloci.FormulaEngine.IReferenceValueProcessor.ProcessValue(System.Object)">
	<summary>Processes a reference value</summary>
	<param name="value">The value from the reference that is to be processed</param>
	<returns>True to keep processing values; False to stop</returns>
	<remarks>This method will be called once for each value that a reference represents.  Classes that implement this interface
 must decide what to do with the value.</remarks>
</member><member name="T:ciloci.FormulaEngine.IReferenceValueProcessor">
	<summary>
 Implemented by classes that process a reference's values
 </summary>
	<remarks>An implementation of this interface can be passed to a reference's <see cref="M:ciloci.FormulaEngine.IReference.GetReferenceValues(ciloci.FormulaEngine.IReferenceValueProcessor)"/> method.  The 
 reference will call the ProcessValue method on each of the values it represents.</remarks>
</member><member name="T:ciloci.FormulaEngine.IFormulaComponent">
	<summary>
 Implemented by objects that compute a formula's result
 </summary>
</member><member name="T:ciloci.FormulaEngine.IOperand">
	<summary>
 Implemented by objects that act as operands to operators and functions in a formula
 </summary>
</member><member name="T:ciloci.FormulaEngine.FormulaFunctionCall">
	<summary>
 Represents the method that will handle a formula function call
 </summary>
	<param name="args">All the arguments that the function was called with</param>
	<param name="result">The object where the function's result will be stored</param>
	<param name="engine">A reference to the formula engine</param>
	<remarks>All methods that you wish to be able to be called from within a formula must have the signature of this delegate.</remarks>
</member><member name="T:ciloci.FormulaEngine.ReferencePredicateBase">
	<summary>
 Base class for a predicate on a reference
 </summary>
</member><member name="T:ciloci.FormulaEngine.ReferenceOperationResultType">
	<summary>
 Result from doing an operation on a reference
 </summary>
</member><member name="M:ciloci.FormulaEngine.ErrorValueWrapper.Equals(System.Object)">
	<summary>
 Convenience function for equality
 </summary>
	<param name="obj">The value to test against</param>
	<returns>True if the wrapper equals obj</returns>
	<remarks>Compares the current wrapper against another value for equality.</remarks>
</member><member name="M:ciloci.FormulaEngine.ErrorValueWrapper.TryParse(System.String)">
	<summary>
 Tries to parse a string in to an error value wrapper
 </summary>
	<param name="s">The string to parse</param>
	<returns>A wrapper instance if the string was sucessfully parsed; a null reference otherwise</returns>
	<remarks>Use this function when you wish to parse a string into an error value wrapper.
 The function recognizes the following strings:
 <list type="bullet">
			<item>"#DIV/0!"</item>
			<item>"#N/A"</item>
			<item>"#NAME?"</item>
			<item>"#NULL!"</item>
			<item>"#REF!"</item>
			<item>"#VALUE!"</item>
			<item>"#NUM!"</item>
		</list>
	</remarks>
</member><member name="M:ciloci.FormulaEngine.ErrorValueWrapper.ToString">
	<summary>
 Formats the inner error value
 </summary>
	<returns>A string with the formatted error</returns>
	<remarks>This method will format an error value similarly to Excel.  For example: the error value Ref will
 be formatted as "#REF!"</remarks>
</member><member name="P:ciloci.FormulaEngine.ErrorValueWrapper.ErrorValue">
	<summary>
 Gets the actual error value that the class contains
 </summary>
	<value>The error value</value>
	<remarks>Returns the error value that the wrapper contains.</remarks>
</member><member name="T:ciloci.FormulaEngine.ErrorValueWrapper">
	<summary>
 A convenient wrapper around an error value
 </summary>
	<remarks>This class encapsulates the parsing and formatting of an <see cref="T:ciloci.FormulaEngine.ErrorValueType"/>.
 It exists so that the error returned by a formula will be nicely formatted without any additional work on the person working
 with the formula engine.</remarks>
</member><member name="T:ciloci.FormulaEngine.ReferenceProperties">
	<summary>
 Base class for properties that are specific to a reference
 </summary>
</member><member name="T:ciloci.FormulaEngine.ReferenceParseProperties">
	<summary>
 Properties resulting from parsing a reference.  Used to pass information from the analyzer to a formula
 </summary>
</member><member name="T:ciloci.FormulaEngine.IFormulaSelfReference">
	<summary>
 Implemented by references that can have a formula bound to them
 </summary>
</member><member name="P:ciloci.FormulaEngine.CircularReferenceDetectedEventArgs.Roots">
	<summary>
 The root of each circular reference
 </summary>
	<value>An array of the circular reference roots</value>
	<remarks>Each reference in this array is the root of a circular reference.  That is, by starting at the reference and
 following all its dependents, you will eventually wind up at the same reference.</remarks>
</member><member name="T:ciloci.FormulaEngine.CircularReferenceDetectedEventArgs">
	<summary>
 Contains information about the cause of circular references
 </summary>
</member><member name="F:ciloci.FormulaEngine.GrammarType.Excel">
	<summary>A grammar suitable for parsing Excel-style formulas</summary>
</member><member name="F:ciloci.FormulaEngine.GrammarType.General">
	<summary>A grammar suitable for general expressions which don't require cell and range references</summary>
</member><member name="T:ciloci.FormulaEngine.GrammarType">
	<summary>
 Defines constants to represent different grammars to use when parsing an expression
 </summary>
	<remarks>Using the constants in this enumeration, you can specify a particular grammar to use when parsing an expression.</remarks>
</member><member name="T:ciloci.FormulaEngine.PrimitiveOperand">
	<summary>
 Base class for a constant, primitive value that can be converted to other values.
 </summary>
</member><member name="M:ciloci.FormulaEngine.SheetCollection.Add(ciloci.FormulaEngine.ISheet)">
	<summary>
 Adds a sheet to the formula engine
 </summary>
	<param name="sheet">The sheet you wish to add</param>
	<remarks>This method registers a sheet with the formula engine.  If sheet is the first sheet in the collection, then it is
 set as the <see cref="P:ciloci.FormulaEngine.SheetCollection.ActiveSheet"/>.</remarks>
	<exception cref="T:System.ArgumentNullException">
 sheet is null
 <para>The sheet's name is null</para>
	</exception>
	<exception cref="T:System.ArgumentException">The sheet already exists in the collection
 <para>A sheet with the same name already exists in the collection</para>
	</exception>
</member><member name="M:ciloci.FormulaEngine.SheetCollection.Remove(ciloci.FormulaEngine.ISheet)">
	<summary>
 Removes a sheet from the collection
 </summary>
	<param name="sheet">The sheet to remove</param>
	<remarks>This method unregisters a sheet from the formula engine.  All references on the removed sheet will become invalid
 and all formulas using those references will be recalculated.</remarks>
	<exception cref="T:System.ArgumentException">The sheet is not contained in the collection</exception>
</member><member name="M:ciloci.FormulaEngine.SheetCollection.Insert(System.Int32,ciloci.FormulaEngine.ISheet)">
	<summary>
 Inserts a sheet into the collection
 </summary>
	<param name="index">The index to insert the sheet at</param>
	<param name="sheet">The sheet to insert</param>
	<remarks>This method lets you insert a sheet at a particular index</remarks>
	<exception cref="T:System.ArgumentOutOfRangeException">index is negative or greater than the sheet count</exception>
	<exception cref="T:System.ArgumentNullException">
 sheet is null
 <para>The sheet's name is null</para>
	</exception>
	<exception cref="T:System.ArgumentException">The sheet already exists in the collection
 <para>A sheet with the same name already exists in the collection</para>
	</exception>
</member><member name="M:ciloci.FormulaEngine.SheetCollection.Contains(ciloci.FormulaEngine.ISheet)">
	<summary>
 Determines if the collection contains a sheet
 </summary>
	<param name="sheet">The sheet to test</param>
	<returns>True if the collection contains the sheet; False otherwise</returns>
	<remarks>This method lets you test whether a particular sheet is contained in the collection</remarks>
</member><member name="M:ciloci.FormulaEngine.SheetCollection.GetSheetByName(System.String)">
	<summary>
 Gets a sheet by name
 </summary>
	<param name="name">The name of the desired sheet</param>
	<returns>An instance of a sheet with the same name; a null reference if no sheet with the name is found</returns>
	<remarks>This method lets you get an instance of a sheet by specifying its name</remarks>
</member><member name="M:ciloci.FormulaEngine.SheetCollection.IndexOf(ciloci.FormulaEngine.ISheet)">
	<summary>
 Gets the index of a sheet in the collection
 </summary>
	<param name="sheet">The sheet whose index you wish to get</param>
	<returns>The index of the sheet; -1 if sheet is not contained in the collection</returns>
	<remarks>A simple method that allows you to get the index of a sheet</remarks>
</member><member name="P:ciloci.FormulaEngine.SheetCollection.ActiveSheet">
	<summary>
 Gets or sets the active sheet of the formula engine
 </summary>
	<value>The active sheet</value>
	<remarks>The active sheet is the sheet used when none is specified.  When creating references via the <see cref="T:ciloci.FormulaEngine.ReferenceFactory"/>,
 this is the sheet that will be used unless one is specified.  The same applies when creating formulas
 that have sheet references that do not explicitly specify a sheet.  This property can be modified at any time.
 <note>The value of this property can only be set to a sheet already contained in the collection</note>
	</remarks>
	<exception cref="T:System.ArgumentException">The property was assigned a sheet that is not in the collection</exception>
	<exception cref="T:System.ArgumentNullException">The property was assigned a null reference</exception>
</member><member name="P:ciloci.FormulaEngine.SheetCollection.Item(System.Int32)">
	<summary>
 Gets a sheet at an index in the collection
 </summary>
	<param name="index">The index of the sheet to retrieve</param>
	<value>The sheet at the specified index</value>
	<remarks>This property is a simple indexer into the collection</remarks>
	<exception cref="T:System.ArgumentOutOfRangeException">index is negative or greater than the index of the last sheet</exception>
</member><member name="P:ciloci.FormulaEngine.SheetCollection.Count">
	<summary>
 Gets the number of sheets in the collection
 </summary>
	<value>The number of sheets in the collection</value>
	<remarks>Use this property when you need to get a count of the number of sheets registered with the formula engine</remarks>
</member><member name="T:ciloci.FormulaEngine.SheetCollection">
	<summary>
 Manages all worksheets within the formula engine
 </summary>
	<remarks>This class is responsible for managing the worksheets that are referenced by formulas.  It provides various collection-oriented methods
 for managing sheets.  Any sheet that you wish to be able to be used in a formula must be registered with this class.</remarks>
</member><member name="M:ciloci.FormulaEngine.ExcelTokenizer.#ctor(System.IO.TextReader)">
	<summary>Creates a new tokenizer for the specified input
stream.</summary>
	<param name="input">the input stream to read</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParserCreationException">if the tokenizer
couldn't be initialized correctly</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelTokenizer.CreatePatterns">
	<summary>Initializes the tokenizer by creating all the token
patterns.</summary>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParserCreationException">if the tokenizer
couldn't be initialized correctly</exception>
</member><member name="T:ciloci.FormulaEngine.ExcelTokenizer">
	<remarks>A character stream tokenizer.</remarks>
</member><member name="M:ciloci.FormulaEngine.Formula.CreateTemplateString(System.String,ciloci.FormulaEngine.ReferenceParseInfo[])">
	<summary>
 Create the template string that we use for formatting this formula.  It will have placeholders where all the
 references will go.  This way, the formula's formatted value will be updated as our references change.
 </summary>
</member><member name="M:ciloci.FormulaEngine.Formula.EvaluateToOperand">
	<summary>
 Evaluate and return the final operand on the stack
 </summary>
</member><member name="M:ciloci.FormulaEngine.Formula.Evaluate">
	<summary>
 Computes the result of the formula
 </summary>
	<returns>The result of evaluating the formula</returns>
	<remarks>This method will compute the result of the current formula.  The formula engine will typically call this method during
 a recalculate but you are free to call it anytime you need the latest result of the formula.  Use this method instead of the
 formula engine's evaluate method if you have a static expression that you wish to evaluate many times</remarks>
	<example>This example shows how you can create a formula and evaluate it.
 <code>
 Dim engine As New FormulaEngine
 Dim f As Formula = engine.CreateFormula("=cos(pi())")
 ' result will contain the value -1 as a Double
 Dim result As Object = f.Evaluate()
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.Formula.GetFinalValue(ciloci.FormulaEngine.IOperand)">
	<summary>
 Get the value that we will expose to the outside
 </summary>
</member><member name="M:ciloci.FormulaEngine.Formula.GetResultOperand(ciloci.FormulaEngine.IOperand)">
	<summary>
 Get the operand based on our result type
 </summary>
</member><member name="M:ciloci.FormulaEngine.Formula.ComputeDependencyReferences">
	<summary>
 Compute the references that will be passed onto the dependency manager.
 </summary>
</member><member name="M:ciloci.FormulaEngine.Formula.GetUniqueValidDependencyReferences(System.Collections.IList)">
	<summary>
 Gets only unique and valid references from the computed dependency reference list
 </summary>
</member><member name="M:ciloci.FormulaEngine.Formula.Parse(System.String,ciloci.FormulaEngine.GrammarType)">
	<summary>
 Parse an expression and return the root of the parse tree
 </summary>
</member><member name="M:ciloci.FormulaEngine.Formula.OffsetReferencesForCopy(ciloci.FormulaEngine.ISheet,System.Int32,System.Int32)">
	<summary>
 Offset all our references for a copy operation
 </summary>
</member><member name="M:ciloci.FormulaEngine.Formula.ToString">
	<summary>
 Returns a string representation of the formula
 </summary>
	<returns>A string representing the formatted value of the formula</returns>
	<remarks>This value will be the same as the expression that the formula was created from except that the text for all references
 is dynamically updated as the references change.</remarks>
</member><member name="P:ciloci.FormulaEngine.Formula.Engine">
	<summary>
 Gets the engine that owns this formula
 </summary>
	<value>The engine that the current formula is bound to</value>
	<remarks>All formulas are owned by a formula engine.  This property gets the engine that owns this particular formula.
 </remarks>
</member><member name="P:ciloci.FormulaEngine.Formula.References">
	<summary>
 Gets all the references that this formula uses
 </summary>
	<value>An array with all the references of the formula</value>
	<remarks>Formulas can reference other cells.  The formula engine analyzes each formula for its references so it can
 determine dependencies.  This property returns all the references that a formula refers to.</remarks>
	<example>A formula such as "=B2+C2" would return an array of two references to cells B2 and C2.  A formula like 
 "=cos(pi())" would return a zero length array since it does not reference any cells.</example>
</member><member name="P:ciloci.FormulaEngine.Formula.SelfReference">
	<summary>
 Gets the reference that this formula is bound to
 </summary>
	<value>The reference where this formula is located</value>
	<remarks>All formulas are bound to a reference.  This property exposes the reference that this particular formula is bound to.
 <note>The value will be null if the formula hasn't been added to a formula engine</note>
	</remarks>
</member><member name="P:ciloci.FormulaEngine.Formula.ResultType">
	<summary>
 Gets or sets the data type of the formula's result
 </summary>
	<value>The data type of the result</value>
	<remarks>This property gives you control over what the data type of this formula's result will be.
 The default is for the formula to evaluate to a primitive.  The most common reason for changing this value is to
 have the formula evaluate to a reference instead of the reference's value.  If the result of evaluating the formula
 cannot be converted to the requested type, the formula will return a Value error.</remarks>
	<example>This sample shows how you can use this property to control what a formula evaluates to:
 <code>
 Dim engine As New FormulaEngine
 Dim f As Formula = Engine.CreateFormula("A1")
 f.ResultType = OperandType.Primitive
 ' result will have the value in cell A1
 Dim result As Object = f.Evaluate()
 f.ResultType = OperandType.SheetReference
 ' result will be a reference to cell A1
 result = f.Evaluate()
 </code>
	</example>
</member><member name="T:ciloci.FormulaEngine.Formula">
	<summary>
 Represents a parsed formula
 </summary>
	<remarks>Instances of this class are created by the formula engine after parsing an expression.  The class contains the compiled
 form of the given expression, exposes some useful properties, and allows you to evaluate the formula and format it.
 </remarks>
</member><member name="M:ciloci.FormulaEngine.ReferencePool.DoReferenceOperation(System.Collections.IList,ciloci.FormulaEngine.ReferenceOperator)">
	<summary>
 Perform an operation on a set of references
 </summary>
</member><member name="T:ciloci.FormulaEngine.ReferencePool">
	<summary>
 Maintains a pool of all references.  This allows formulas to re-use instances of a reference so that when a reference changes, all formulas
 that use it will see the change.  It uses simple reference counting to ensure that unused references are released.
 </summary>
</member><member name="T:ciloci.FormulaEngine.OperatorBase">
	<summary>
 Base class for all operators
 </summary>
</member><member name="T:ciloci.FormulaEngine.UnaryOperator">
	<summary>
 Represents an operator on one operand
 </summary>
</member><member name="T:ciloci.FormulaEngine.BinaryOperator">
	<summary>
 An operator on two operands
 </summary>
</member><member name="T:ciloci.FormulaEngine.GeneralConstants">
	<remarks>An enumeration with token and production node
constants.</remarks>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.Enter(PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.Exit(PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.Child(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterAdd(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitAdd(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterSub(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitSub(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterMul(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitMul(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterDiv(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitDiv(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterExp(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitExp(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterConcat(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitConcat(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterLeftParen(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitLeftParen(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterRightParen(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitRightParen(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterPercent(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitPercent(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterArgSeparator(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitArgSeparator(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterEq(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitEq(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterLt(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitLt(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterGt(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitGt(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterLte(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitLte(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterGte(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitGte(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterNe(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitNe(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterStringLiteral(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitStringLiteral(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterNumber(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitNumber(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterTrue(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitTrue(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterFalse(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitFalse(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterFunctionName(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitFunctionName(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterDivError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitDivError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterNaError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitNaError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterNameError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitNameError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterNullError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitNullError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterRefError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitRefError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterValueError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitValueError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterNumError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitNumError(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterCell(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitCell(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterCellRange(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitCellRange(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterRowRange(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitRowRange(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterColumnRange(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitColumnRange(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterSheetName(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitSheetName(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterDefinedName(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitDefinedName(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterFormula(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitFormula(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildFormula(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterScalarFormula(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitScalarFormula(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildScalarFormula(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterPrimaryExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitPrimaryExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildPrimaryExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterLogicalExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitLogicalExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildLogicalExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterLogicalOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitLogicalOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildLogicalOp(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterConcatExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitConcatExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildConcatExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterAdditiveExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitAdditiveExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildAdditiveExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterAdditiveOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitAdditiveOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildAdditiveOp(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterMultiplicativeExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitMultiplicativeExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildMultiplicativeExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterMultiplicativeOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitMultiplicativeOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildMultiplicativeOp(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterExponentiationExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitExponentiationExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildExponentiationExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterPercentExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitPercentExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildPercentExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterUnaryExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitUnaryExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildUnaryExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterBasicExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitBasicExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildBasicExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterReference(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitReference(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildReference(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterGridReferenceExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitGridReferenceExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildGridReferenceExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterGridReference(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitGridReference(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildGridReference(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterFunctionCall(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitFunctionCall(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildFunctionCall(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterArgumentList(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitArgumentList(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildArgumentList(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterExpressionGroup(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitExpressionGroup(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildExpressionGroup(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterPrimitive(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitPrimitive(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildPrimitive(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterBoolean(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitBoolean(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildBoolean(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.EnterErrorExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ExitErrorExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.ExcelAnalyzer.ChildErrorExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="T:ciloci.FormulaEngine.ExcelAnalyzer">
	<remarks>A class providing callback methods for the
parser.</remarks>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.Enter(PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.Exit(PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.Child(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterAdd(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitAdd(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterSub(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitSub(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterMul(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitMul(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterDiv(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitDiv(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterExp(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitExp(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterConcat(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitConcat(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterLeftParen(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitLeftParen(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterRightParen(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitRightParen(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterPercent(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitPercent(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterArgSeparator(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitArgSeparator(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterEq(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitEq(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterLt(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitLt(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterGt(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitGt(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterLte(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitLte(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterGte(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitGte(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterNe(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitNe(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterStringLiteral(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitStringLiteral(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterNumber(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitNumber(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterTrue(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitTrue(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterFalse(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitFalse(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterFunctionName(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitFunctionName(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterDefinedName(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitDefinedName(PerCederberg.Grammatica.Runtime.Token)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterFormula(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitFormula(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildFormula(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterLogicalExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitLogicalExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildLogicalExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterLogicalOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitLogicalOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildLogicalOp(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterConcatExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitConcatExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildConcatExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterAdditiveExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitAdditiveExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildAdditiveExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterAdditiveOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitAdditiveOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildAdditiveOp(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterMultiplicativeExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitMultiplicativeExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildMultiplicativeExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterMultiplicativeOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitMultiplicativeOp(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildMultiplicativeOp(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterExponentiationExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitExponentiationExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildExponentiationExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterPercentExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitPercentExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildPercentExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterUnaryExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitUnaryExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildUnaryExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterBasicExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitBasicExpression(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildBasicExpression(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterFunctionCall(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitFunctionCall(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildFunctionCall(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterArgumentList(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitArgumentList(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildArgumentList(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterExpressionGroup(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitExpressionGroup(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildExpressionGroup(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterPrimitive(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitPrimitive(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildPrimitive(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.EnterBoolean(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when entering a parse tree node.</summary>
	<param name="node">the node being entered</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ExitBoolean(PerCederberg.Grammatica.Runtime.Production)">
	<summary>Called when exiting a parse tree node.</summary>
	<param name="node">the node being exited</param>
	<returns>the node to add to the parse tree, or
         null if no parse tree should be created</returns>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralAnalyzer.ChildBoolean(PerCederberg.Grammatica.Runtime.Production,PerCederberg.Grammatica.Runtime.Node)">
	<summary>Called when adding a child to a parse tree
node.</summary>
	<param name="node">the parent node</param>
	<param name="child">the child node, or null</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParseException">if the node analysis
discovered errors</exception>
</member><member name="T:ciloci.FormulaEngine.GeneralAnalyzer">
	<remarks>A class providing callback methods for the
parser.</remarks>
</member><member name="T:ciloci.FormulaEngine.FunctionLibrary.FunctionInfo">
	<summary>
 Stores all information about a function
 </summary>
</member><member name="F:ciloci.FormulaEngine.FunctionLibrary.MAX_ARGUMENT_COUNT">
	<summary>The maximum number of arguments that any function can be called with</summary>
	<remarks>This limit is arbitrary but is implemented to prevent functions being called with an unreasonable number of arguments</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionLibrary.AddBuiltinFunctions">
	<summary>
 Adds all builtin functions to the library
 </summary>
	<remarks>Use this method when you want to add all the builtin functions to the library.  Builtin functions are added by
 default when the function library is created.</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionLibrary.AddInstanceFunctions(System.Object)">
	<summary>
 Adds all instance methods of the given object that can be formula functions
 </summary>
	<param name="instance">The object whose methods you wish to add</param>
	<remarks>Use this function when you want to add a large number of functions in bulk.  The method will search all instance methods
 of the type.  Methods that are tagged with a formula function attribute and have the correct signature will be added to the library.</remarks>
	<exception cref="T:System.ArgumentNullException">instance is null</exception>
	<exception cref="T:System.ArgumentException">A method is tagged with a formula function attribute but does not have the correct signature</exception>
	<exception cref="T:System.InvalidOperationException">
 The function was called while formulas are defined in the formula engine
 <para>A function with the same name is already defined</para>
	</exception>
</member><member name="M:ciloci.FormulaEngine.FunctionLibrary.AddStaticFunctions(System.Type)">
	<summary>
 Adds all static methods of the given type that can be formula functions
 </summary>
	<param name="target">The type to examine</param>
	<remarks>This method works similarly to <see cref="M:ciloci.FormulaEngine.FunctionLibrary.AddInstanceFunctions(System.Object)"/> except that it looks at all static methods instead.</remarks>
	<exception cref="T:System.ArgumentNullException">target is null</exception>
	<exception cref="T:System.ArgumentException">A method is tagged with a formula function attribute but does not have the correct signature</exception>
	<exception cref="T:System.InvalidOperationException">
 The function was called while formulas are defined in the formula engine
 <para>A function with the same name is already defined</para>
	</exception>
</member><member name="M:ciloci.FormulaEngine.FunctionLibrary.AddFormulaMethods(System.Type,ciloci.FormulaEngine.FunctionLibrary.IDelegateCreator)">
	<summary>
 Go through all methods of a type and try to add them as formula functions
 </summary>
</member><member name="M:ciloci.FormulaEngine.FunctionLibrary.AddFunction(ciloci.FormulaEngine.FormulaFunctionCall)">
	<summary>
 Adds an individual formula function
 </summary>
	<param name="functionCall">A delegate pointing to the method you wish to add</param>
	<remarks>This function lets you add an individual formula function by specifying a delegate pointing to it.  The method that
 the delegate refers to must be tagged with the appropriate <see cref="T:ciloci.FormulaEngine.FormulaFunctionAttribute">attribute</see>.</remarks>
	<exception cref="T:System.ArgumentException">The method that the delegate points to is not tagged with the required attribute</exception>
	<exception cref="T:System.InvalidOperationException">
 The function was called while formulas are defined in the formula engine
 <para>A function with the same name is already defined</para>
	</exception>
</member><member name="M:ciloci.FormulaEngine.FunctionLibrary.RemoveFunction(System.String)">
	<summary>
 Undefines an individual function
 </summary>
	<param name="functionName">The name of the function you wish to undefine</param>
	<remarks>This method removes a function from the library</remarks>
	<exception cref="T:System.ArgumentException">The given function name is not defined</exception>
	<exception cref="T:System.InvalidOperationException">The function was called while formulas are defined in the formula engine</exception>
</member><member name="M:ciloci.FormulaEngine.FunctionLibrary.InvokeFunction(System.String,System.Collections.Stack,System.Int32)">
	<summary>
 Perform a function call
 </summary>
</member><member name="M:ciloci.FormulaEngine.FunctionLibrary.MarshalArguments(ciloci.FormulaEngine.FunctionLibrary.FunctionInfo,ciloci.FormulaEngine.IOperand[])">
	<summary>
 Perform validation on operands passed to a function
 </summary>
</member><member name="M:ciloci.FormulaEngine.FunctionLibrary.GetFunctionNames">
	<summary>
 Gets the names of all defined functions
 </summary>
	<returns>An array consisting of the names of all defined functions</returns>
	<remarks>Use this method when you need the names of all defined functions</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionLibrary.Clear">
	<summary>
 Undefines all functions
 </summary>
	<remarks>This method undefines all functions in the library</remarks>
	<exception cref="T:System.InvalidOperationException">The function was called while formulas are defined in the formula engine</exception>
</member><member name="P:ciloci.FormulaEngine.FunctionLibrary.FunctionCount">
	<summary>
 Gets the number of functions defined in the library
 </summary>
	<value>A count of the number of defined functions</value>
	<remarks>Use this property when you need to know the number of defined functions in the library</remarks>
</member><member name="T:ciloci.FormulaEngine.FunctionLibrary">
	<summary>
 Manages all functions that can be used in formulas
 </summary>
	<remarks>This class is responsible for managing all functions used in formulas and for marshalling arguments during function calls.
 It has methods for defining and undefining formula functions in bulk or individually.  The library comes with many of the most
 common Excel functions already defined.  If a function is not defined in this class then an error will be generated when
 a formula tries to use it.
 <para>Adding your own function to the library requires the following steps:
 <list type="bullet">
				<item>Define a method that has the same signature as the <see cref="T:ciloci.FormulaEngine.FormulaFunctionCall">delegate</see></item>
				<item>Tag the method with either the <see cref="T:ciloci.FormulaEngine.FixedArgumentFormulaFunctionAttribute"/> or <see cref="T:ciloci.FormulaEngine.VariableArgumentFormulaFunctionAttribute"/> attributes</item>
				<item>Add the function to the function library using one of the appropriate methods</item>
			</list>
		</para>
		<note>Function names are treated case-insensitively
 <para>You cannot define/undefine functions while formulas are defined in the formula engine</para>
		</note>
	</remarks>
</member><member name="M:ciloci.FormulaEngine.Argument.IsType(ciloci.FormulaEngine.OperandType)">
	<summary>
 Determines if this argument can be converted to a particular type
 </summary>
	<param name="opType">The operand type you wish to test</param>
	<returns>True if the argument can be converted to opType; False otherwise</returns>
	<remarks>This method is a more generic version of the IsXXX properties</remarks>
</member><member name="P:ciloci.FormulaEngine.Argument.ValueAsDouble">
	<summary>
 Gets the value of an argument as a <see cref="T:System.Double"/>
	</summary>
	<value>The value of the argument as a <see cref="T:System.Double"/></value>
	<remarks>This property will try to convert the value of the argument to a <see cref="T:System.Double"/>.</remarks>
	<exception cref="T:System.InvalidOperationException">The value could not be converted to a <see cref="T:System.Double"/></exception>
</member><member name="P:ciloci.FormulaEngine.Argument.ValueAsInteger">
	<summary>
 Gets the value of an argument as an <see cref="T:System.Int32"/>
	</summary>
	<value>The value of the argument as an <see cref="T:System.Int32"/></value>
	<remarks>This property will try to convert the value of the argument to an <see cref="T:System.Int32"/>.</remarks>
	<exception cref="T:System.InvalidOperationException">The value could not be converted to an <see cref="T:System.Int32"/></exception>
</member><member name="P:ciloci.FormulaEngine.Argument.ValueAsString">
	<summary>
 Gets the value of an argument as a <see cref="T:System.String"/>
	</summary>
	<value>The value of the argument as a <see cref="T:System.String"/></value>
	<remarks>This property will try to convert the value of the argument to a <see cref="T:System.String"/>.</remarks>
	<exception cref="T:System.InvalidOperationException">The value could not be converted to a <see cref="T:System.String"/></exception>
</member><member name="P:ciloci.FormulaEngine.Argument.ValueAsBoolean">
	<summary>
 Gets the value of an argument as a <see cref="T:System.Boolean"/>
	</summary>
	<value>The value of the argument as a <see cref="T:System.Boolean"/></value>
	<remarks>This property will try to convert the value of the argument to a <see cref="T:System.Boolean"/>.</remarks>
	<exception cref="T:System.InvalidOperationException">The value could not be converted to a <see cref="T:System.Boolean"/></exception>
</member><member name="P:ciloci.FormulaEngine.Argument.ValueAsDateTime">
	<summary>
 Gets the value of an argument as a <see cref="T:System.DateTime"/>
	</summary>
	<value>The value of the argument as a <see cref="T:System.DateTime"/></value>
	<remarks>This property will try to convert the value of the argument to a <see cref="T:System.DateTime"/>.</remarks>
	<exception cref="T:System.InvalidOperationException">The value could not be converted to a <see cref="T:System.DateTime"/></exception>
</member><member name="P:ciloci.FormulaEngine.Argument.ValueAsError">
	<summary>
 Gets the value of an argument as an <see cref="T:System.ciloci.FormulaEngine.ErrorValueType"/>
	</summary>
	<value>The value of the argument as an <see cref="T:System.ciloci.FormulaEngine.ErrorValueType"/></value>
	<remarks>This property will try to convert the value of the argument to an <see cref="T:System.ciloci.FormulaEngine.ErrorValueType"/>.</remarks>
	<exception cref="T:System.InvalidOperationException">The value could not be converted to an <see cref="T:System.ciloci.FormulaEngine.ErrorValueType"/></exception>
</member><member name="P:ciloci.FormulaEngine.Argument.ValueAsReference">
	<summary>
 Gets the value of an argument as a reference
 </summary>
	<value>The value of the argument as a reference</value>
	<remarks>This property will try to convert the value of the argument to a reference.</remarks>
	<exception cref="T:System.InvalidOperationException">The value could not be converted to a reference</exception>
</member><member name="P:ciloci.FormulaEngine.Argument.ValueAsPrimitive">
	<summary>
 Gets the value of an argument as a primitive
 </summary>
	<value>The value of the argument as a primitive</value>
	<remarks>This property will try to convert the value of the argument to a primitive.  A primitive is any datatype except a reference.</remarks>
	<exception cref="T:System.InvalidOperationException">The value could not be converted to a primitive</exception>
</member><member name="P:ciloci.FormulaEngine.Argument.IsDouble">
	<summary>
 Indicates whether this argument is a double
 </summary>
	<value>True if the argument can be converted to a double; False otherwise</value>
	<remarks>Use this property to test if the argument can be converted to a particular data type before trying to get its value.</remarks>
</member><member name="P:ciloci.FormulaEngine.Argument.IsInteger">
	<summary>
 Indicates whether this argument is an integer
 </summary>
	<value>True if the argument can be converted to an integer; False otherwise</value>
	<remarks>Use this property to test if the argument can be converted to a particular data type before trying to get its value.</remarks>
</member><member name="P:ciloci.FormulaEngine.Argument.IsString">
	<summary>
 Indicates whether this argument is a string
 </summary>
	<value>True if the argument can be converted to a string; False otherwise</value>
	<remarks>Use this property to test if the argument can be converted to a particular data type before trying to get its value.</remarks>
</member><member name="P:ciloci.FormulaEngine.Argument.IsBoolean">
	<summary>
 Indicates whether this argument is a boolean
 </summary>
	<value>True if the argument can be converted to a boolean; False otherwise</value>
	<remarks>Use this property to test if the argument can be converted to a particular data type before trying to get its value.</remarks>
</member><member name="P:ciloci.FormulaEngine.Argument.IsReference">
	<summary>
 Indicates whether this argument is a reference
 </summary>
	<value>True if the argument can be converted to a reference; False otherwise</value>
	<remarks>Use this property to test if the argument can be converted to a particular data type before trying to get its value.</remarks>
</member><member name="P:ciloci.FormulaEngine.Argument.IsError">
	<summary>
 Indicates whether this argument is an error value
 </summary>
	<value>True if the argument can be converted to an error value; False otherwise</value>
	<remarks>Use this property to test if the argument can be converted to a particular data type before trying to get its value.</remarks>
</member><member name="P:ciloci.FormulaEngine.Argument.IsDateTime">
	<summary>
 Indicates whether this argument is a DateTime
 </summary>
	<value>True if the argument can be converted to a DateTime; False otherwise</value>
	<remarks>Use this property to test if the argument can be converted to a particular data type before trying to get its value.</remarks>
</member><member name="P:ciloci.FormulaEngine.Argument.IsPrimitive">
	<summary>
 Indicates whether this argument is a primitive
 </summary>
	<value>True if the argument can be converted to a primitive; False otherwise</value>
	<remarks>Use this property to test if the argument can be converted to a particular data type before trying to get its value.
 A primitive is any data type except a reference.</remarks>
</member><member name="T:ciloci.FormulaEngine.Argument">
	<summary>
 Represents an argument to a formula function
 </summary>
	<remarks>This class represents an argument passed to a formula function.  Every such function will
 receive an array of instances of this class; one for each argument the function was called with.  The class has properties
 for determining the type of the argument passed and getting its value.</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionResult.SetValue(System.Double)">
	<summary>
 Sets the formula function result to a double
 </summary>
	<param name="value">The value you wish to be the result of the function</param>
	<remarks>Use this method when the result of your function is a double</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionResult.SetValue(System.Int32)">
	<summary>
 Sets the formula function result to an integer
 </summary>
	<param name="value">The value you wish to be the result of the function</param>
	<remarks>Use this method when the result of your function is an integer</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionResult.SetValue(System.Boolean)">
	<summary>
 Sets the formula function result to a boolean
 </summary>
	<param name="value">The value you wish to be the result of the function</param>
	<remarks>Use this method when the result of your function is a boolean</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionResult.SetValue(System.String)">
	<summary>
 Sets the formula function result to a string
 </summary>
	<param name="value">The value you wish to be the result of the function</param>
	<remarks>Use this method when the result of your function is a string</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionResult.SetValue(System.DateTime)">
	<summary>
 Sets the formula function result to a DateTime
 </summary>
	<param name="value">The value you wish to be the result of the function</param>
	<remarks>Use this method when the result of your function is a DateTime</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionResult.SetError(ciloci.FormulaEngine.ErrorValueType)">
	<summary>
 Sets the formula function result to an error
 </summary>
	<param name="value">The type of the error you wish to be the result of the function</param>
	<remarks>Use this method when you need to return an error as the result of your function</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionResult.SetValue(ciloci.FormulaEngine.IReference)">
	<summary>
 Sets the formula function result to a reference
 </summary>
	<param name="value">The value you wish to be the result of the function</param>
	<remarks>Use this method when the result of your function is a reference.  Usually used when wishing to implement dynamic references</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionResult.SetValue(ciloci.FormulaEngine.Argument)">
	<summary>
 Sets the formula function result to a given argument
 </summary>
	<param name="arg">The value you wish to be the result of the function</param>
	<remarks>Use this method when you wish to use one of the arguments supplied to your function as its result without altering the value.
 The if function, for example, uses this method.</remarks>
</member><member name="M:ciloci.FormulaEngine.FunctionResult.SetValueFromSheet(System.Object)">
	<summary>
 Sets the formula function result to a sheet value
 </summary>
	<param name="value">The value you wish to be the result of the function</param>
	<remarks>Use this method when you have a value on a sheet that you wish to use as the result of your function</remarks>
</member><member name="T:ciloci.FormulaEngine.FunctionResult">
	<summary>
 Represents the result of a formula function
 </summary>
	<remarks>This class is responsible for storing the result of a formula function.  It has methods for storing a result of
 various data types.  An instance of it is passed to all methods acting as formula functions and each such method must produce
 a result and store it in the passed instance or an exception will be raised.</remarks>
	<example>This example shows a formula function that expects one argument of type double and sets its result as that value incremented by one:
 <code>
 &lt;FixedArgumentFormulaFunction(1, New OperandType() {OperandType.Double})&gt; _
 Public Sub PlusOne(ByVal args As Argument(), ByVal result As FunctionResult, ByVal engine As FormulaEngine)
		Dim value as Double = args(0).ValueAsDouble
		result.SetValue(value + 1)
 End Sub
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.VariableArgumentFunctionProcessor.ProcessArguments(ciloci.FormulaEngine.Argument[])">
	<summary>
 Processes all arguments to a variable argument formula function
 </summary>
	<param name="args">The arguments to process</param>
	<returns>True if processing was sucessful; False otherwise</returns>
	<remarks>This is the main method responsible for processing the function's arguments.  It handles the processing of 
 primitive arguments and the processing of each value of a reference argument.</remarks>
</member><member name="M:ciloci.FormulaEngine.VariableArgumentFunctionProcessor.ProcessPrimitiveArgument(ciloci.FormulaEngine.Argument)">
	<summary>
 Implemented by a derived class to handle processing of a primitive argument
 </summary>
	<param name="arg">The primitive argument to process</param>
	<returns>True if processing was successful; False otherwise</returns>
	<remarks>This method will get called for each argument that is not a reference.  It is up to the derived class to decide what
 to do with each such argument.</remarks>
</member><member name="M:ciloci.FormulaEngine.VariableArgumentFunctionProcessor.ProcessEmptyValue">
	<summary>
 Indicates how an empty reference value should be processed
 </summary>
	<remarks>This method will get called for each value of a reference that is null.  Derived classes would override this method
 if they need to handle null values in a special way.</remarks>
</member><member name="M:ciloci.FormulaEngine.VariableArgumentFunctionProcessor.OnErrorReferenceValue(ciloci.FormulaEngine.ErrorValueWrapper)">
	<summary>
 Determines how a reference value that is an error should be handled
 </summary>
	<param name="value">The error value</param>
	<remarks>This method will get called for each value of a reference that is an error value.  Derived classes can override
 this method to provide custom handling for such values.</remarks>
</member><member name="M:ciloci.FormulaEngine.VariableArgumentFunctionProcessor.ProcessReferenceValue(System.Object,System.Type)">
	<summary>
 Determines how a non-empty reference value will be processed
 </summary>
	<param name="value">The value to process</param>
	<param name="valueType">The value's type</param>
	<remarks>Derived classes must override this method to provide customized handling of a reference's values.  This method only deals
 with non-empty values and thus the value parameter will never be null.</remarks>
</member><member name="M:ciloci.FormulaEngine.VariableArgumentFunctionProcessor.IsError(System.Type)">
	<summary>
 Determines if a type represents an error
 </summary>
	<param name="t">The type to test</param>
	<returns>True is the type represents an error; False otherwise</returns>
	<remarks>This function is handy when you need to determine if the type of a value is an error.</remarks>
</member><member name="M:ciloci.FormulaEngine.VariableArgumentFunctionProcessor.SetError(ciloci.FormulaEngine.ErrorValueType)">
	<summary>
 Sets the error that will be reported at the end of processing
 </summary>
	<param name="errorType">The type of error to set</param>
	<remarks>Derived classes can use this method when they encounter an error during argument processing.  When processing is finished,
 this value will be returned by the <see cref="P:ciloci.FormulaEngine.VariableArgumentFunctionProcessor.ErrorValue"/> property to callers who
 need to know why processing failed.</remarks>
</member><member name="P:ciloci.FormulaEngine.VariableArgumentFunctionProcessor.StopOnError">
	<summary>
 Determines if processing stops upon encountering an error value
 </summary>
	<value>True if processing should stop when an error value is encountered; False to keep going</value>
	<remarks>Some functions, like Sum, do not handle error values and need to stop at the first one they encounter.  Other functions
 like Count, simply ignore the value and keep going.  Derived classes must override this property so as to specify their way
 of handling error values.</remarks>
</member><member name="P:ciloci.FormulaEngine.VariableArgumentFunctionProcessor.ErrorValue">
	<summary>
 Gets the error that caused processing to fail
 </summary>
	<value>An error value</value>
	<remarks>When processing of arguments fails, this property will indicate the specific error that is the cause.  The caller can check
 this property and set the result of the function accordingly.</remarks>
</member><member name="T:ciloci.FormulaEngine.VariableArgumentFunctionProcessor">
	<summary>
 Provides a framework for processing the arguments of a variable argument formula function
 </summary>
	<remarks>This class provides a more reusable approach to processing the arguments of formula functions that 
 take a variable number of arguments.  Processing the arguments to such functions requires differentiating between
 reference and primitive arguments, deciding how to handle error and null values, and even transforming values.  This class
 handles the core processing of these tasks and lets derived classes handle the details specific to each function.</remarks>
</member><member name="T:ciloci.FormulaEngine.DoubleBasedReferenceValueProcessor">
	<summary>
 Processor that works with a list of doubles
 </summary>
</member><member name="T:ciloci.FormulaEngine.CountBasedReferenceValueProcessor">
	<summary>
 Processor that keeps a count of values
 </summary>
</member><member name="T:ciloci.FormulaEngine.FormulaFunctionAttribute">
	<summary>
 The base class for all attributes that mark formula function methods
 </summary>
	<remarks>This attribute is the base class for the <see cref="T:ciloci.FormulaEngine.FixedArgumentFormulaFunctionAttribute"/> and <see cref="T:ciloci.FormulaEngine.VariableArgumentFormulaFunctionAttribute"/> classes.
 All methods that you wish to be able to be used in formulas must be marked with one of those attributes.  By
 doing so, you give the formula engine information about the number and type of arguments that your function requires.
 This allows the engine to only call your function with the correct number and type of arguments and
 eliminates the need for each function author to write manual validation code.</remarks>
	<example>This example shows a method tagged with this attribute.  The formula engine will only call this method
 if it is called with exactly one argument and that argument can be converted into a double.
 <code>
 &lt;FixedArgumentFormulaFunction(1, New OperandType() {OperandType.Double})&gt; _
 Public Sub PlusOne(ByVal args As Argument(), ByVal result As FunctionResult, ByVal engine As FormulaEngine)
		Dim value as Double = args(0).ValueAsDouble
		result.SetValue(value + 1)
 End Sub
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.FixedArgumentFormulaFunctionAttribute.#ctor(System.Int32,System.Int32,ciloci.FormulaEngine.OperandType[])">
	<summary>
 Declares a formula function with an optional number of arguments
 </summary>
	<param name="minArgumentCount">The minimum number of arguments your function expects</param>
	<param name="maxArgumentCount">The maximum number of arguments your function expects</param>
	<param name="argumentTypes">An array of <see cref="T:ciloci.FormulaEngine.OperandType"/> that specifies the type of each argument your function expects</param>
	<remarks>Use this constructor when your function can have optional arguments.  The formula engine will allow calls to your function
 as long as at least minArgumentCount arguments and no more than maxArgumentCount arguments are specified.  Calls with a number of arguments
 between the two values will be allowed and it is up to you to interpret the values of the unspecified arguments.  You must specify the
 type of all arguments including optional ones.</remarks>
	<exception cref="T:System.ArgumentOutOfRangeException">
		<para>minArgumentCount is negative</para>
		<para>maxArgumentCount exceeds the <see cref="F:ciloci.FormulaEngine.FunctionLibrary.MAX_ARGUMENT_COUNT">maximum</see> number of allowed arguments</para>
		<para>maxArgumentCount is less than minArgumentCount</para>
		<para>The number of argument types is not equal to maxArgumentCount</para>
	</exception>
	<exception cref="T:System.ArgumentNullException">
		<para>argumentTypes is null</para>
	</exception>
	<example>The following example declares the method Ceiling as a formula function that be called with one or two Double arguments
 <code>
 &lt;FixedArgumentFormulaFunction(1, 2, New OperandType() {OperandType.Double, OperandType.Double})&gt; _
 Public Sub Ceiling(ByVal args As Argument(), ByVal result As FunctionResult, ByVal engine As FormulaEngine)
 End Sub
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.FixedArgumentFormulaFunctionAttribute.#ctor(System.Int32,ciloci.FormulaEngine.OperandType[])">
	<summary>
 Declares a formula function with a fixed number of arguments
 </summary>
	<param name="argumentCount">The number of arguments your function expects</param>
	<param name="argumentTypes">The type of each argument</param>
	<remarks>Use this constructor when your function requires an exact number of arguments.  You must specify
 the count you want and the type of each argument.</remarks>
	<example>The following example declares a method as taking one argument of type Double
 <code>
 &lt;FixedArgumentFormulaFunction(1, New OperandType() {OperandType.Double})&gt; _
 Public Sub Tan(ByVal args As Argument(), ByVal result As FunctionResult, ByVal engine As FormulaEngine)
 End Sub
 </code>
	</example>
</member><member name="T:ciloci.FormulaEngine.FixedArgumentFormulaFunctionAttribute">
	<summary>
 Marks a method as a formula function that takes a fixed number of arguments
 </summary>
	<remarks>By tagging a method with this attribute, you are informing the formula engine that your method expects a fixed
 number of arguments and lets you specify their type.  All calls to a function marked with this attribute will only happen
 if the number and type of arguments match the ones specified.</remarks>
	<example>The following example declares the method Tan as a formula function taking one argument of type Double
 <code>
 &lt;FixedArgumentFormulaFunction(1, New OperandType() {OperandType.Double})&gt; _
 Public Sub Tan(ByVal args As Argument(), ByVal result As FunctionResult, ByVal engine As FormulaEngine)
 End Sub
 </code>
	</example>
</member><member name="T:ciloci.FormulaEngine.VariableArgumentFormulaFunctionAttribute">
	<summary>
 Marks a formula function as taking a variable number of arguments
 </summary>
	<remarks>Use this attribute on a method that you wish to act as a formula function with a variable number of arguments.
 The formula engine will allow calls to your method as long as it is called with at least one and no more than <see cref="F:ciloci.FormulaEngine.FunctionLibrary.MAX_ARGUMENT_COUNT"/>
 arguments.  No validation is done on the type of each argument; it is up to you to examine each one and act on it as you see fit</remarks>
	<example>The following example declares the method sum as a formula function taking a variable number of arguments
 <code>
 &lt;VariableArgumentFormulaFunction()&gt; _
 Public Sub Sum(ByVal args As Argument(), ByVal result As FunctionResult, ByVal engine As FormulaEngine)
 End Sub
 </code>
	</example>
</member><member name="T:ciloci.FormulaEngine.VolatileFunctionAttribute">
	<summary>
 Marks a formula function as being volatile
 </summary>
	<remarks>Apply this attribute to a formula function to make the formula engine treat it as volatile.
 Formulas with volatile functions are always included in any recalculations even if they do not depend on any of the references
 being recalculated.  The typical reason why a function would be marked as volatile is that it creates or uses dynamic references
 and thus the formula engine cannot determine any dependencies.  Without this attribute, such a function would never be recalculated.</remarks>
</member><member name="T:ciloci.FormulaEngine.SheetValuePredicate">
	<summary>
 Base class for predicates used in conditional functions like SumIf
 </summary>
</member><member name="T:ciloci.FormulaEngine.Reference">
	<summary>
 Base class for all references
 </summary>
</member><member name="T:ciloci.FormulaEngine.SheetReference">
	<summary>
 Base class for references that are on a sheet
 </summary>
</member><member name="T:ciloci.FormulaEngine.NonGridReference">
	<summary>
 Base class for references that aren't on a sheet
 </summary>
</member><member name="T:ciloci.FormulaEngine.CustomExcelAnalyzer">
	<summary>
 Processes the parse tree and generates the information necessary to build a formula
 </summary>
</member><member name="T:ciloci.FormulaEngine.GeneralParser.SynteticPatterns">
	<summary>An enumeration with the generated production node
identity constants.</summary>
</member><member name="M:ciloci.FormulaEngine.GeneralParser.#ctor(System.IO.TextReader)">
	<summary>Creates a new parser.</summary>
	<param name="input">the input stream to read from</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParserCreationException">if the parser
couldn't be initialized correctly</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralParser.#ctor(System.IO.TextReader,PerCederberg.Grammatica.Runtime.Analyzer)">
	<summary>Creates a new parser.</summary>
	<param name="input">the input stream to read from</param>
	<param name="analyzer">the analyzer to parse with</param>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParserCreationException">if the parser
couldn't be initialized correctly</exception>
</member><member name="M:ciloci.FormulaEngine.GeneralParser.CreatePatterns">
	<summary>Initializes the parser by creating all the production
patterns.</summary>
	<exception cref="T:PerCederberg.Grammatica.Runtime.ParserCreationException">if the parser
couldn't be initialized correctly</exception>
</member><member name="T:ciloci.FormulaEngine.GeneralParser">
	<remarks>A token stream parser.</remarks>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Parse(System.String)">
	<summary>
 Creates a sheet reference from a string
 </summary>
	<param name="s">A string that contains a sheet reference expression</param>
	<returns>A sheet reference parsed from the given string</returns>
	<remarks>This method creates a sheet reference by parsing a given string.
 The method accepts strings with the following syntax:
 <list type="table">
			<listheader><term>String format</term><description>Resultant reference</description></listheader>
			<item>
				<term>Column letter followed by a row number: "C3"</term><description>Cell</description>
			</item>
			<item>
				<term>Two column letter and row number pairs separated by a colon: "C3:D4"</term><description>Cell range</description>
			</item>
			<item>
				<term>Two column letters separated by a colon: "E:G"</term><description>Columns</description>
			</item>
			<item>
				<term>Two row numbers separated by a colon: "4:6"</term><description>Rows</description>
			</item>
		</list>
 All of the above formats can specify a specific sheet by prefixing the reference with a sheet name
 followed by an exclamation point (ie: "Sheet2!E:G")
 If no sheet name is specified, the currently active sheet is used.
 </remarks>
	<example>This example shows how you would create sheet references from various strings
 <code>
 ' Get a reference to cell A1
 Dim cellRef As ISheetReference = factory.Parse("A1")
 ' Get a reference to cells B2 through E4
 Dim rangeRef As ISheetReference = factory.Parse("b2:e4")
 ' Get a reference to columns D through F
 Dim colsRef As ISheetReference = factory.Parse("D:F")
 'Get a reference to rows 4 through 6
 Dim rowsRef As ISheetReference = factory.Parse("4:6")
 ' Get a reference to cell C4 on sheet 'Sheet4'
 Dim cellRef As ISheetReference = factory.Parse("Sheet4!C4")
 </code>
	</example>
	<exception cref="T:System.ArgumentException">
		<para>The given string could not be parsed into a sheet reference</para>
		<para>The string references a sheet name that is not defined</para>
		<para>The resulting sheet reference is not within the bounds of its sheet</para>
	</exception>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.FromRectangle(System.Drawing.Rectangle)">
	<summary>
 Creates a sheet reference from a rectangle
 </summary>
	<param name="rect">The rectangle to create the sheet reference from</param>
	<returns>A sheet reference that matches the given rectangle</returns>
	<remarks>This method is identical to <see cref="M:ciloci.FormulaEngine.ReferenceFactory.FromRectangle(ciloci.FormulaEngine.ISheet,System.Drawing.Rectangle)"/>
 except that the returned reference is on the currently active sheet.
 </remarks>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.FromRectangle(ciloci.FormulaEngine.ISheet,System.Drawing.Rectangle)">
	<summary>
 Creates a sheet reference from a rectangle and a sheet
 </summary>
	<param name="rect">The rectangle to create the sheet reference from</param>
	<param name="sheet">The sheet that the reference will be on</param>
	<returns>A sheet reference that matches the given rectangle and is on the given sheet</returns>
	<remarks>Use this method when you have a rectangle that you would like translated into a sheet reference.  Note that the
 top-left corner of the sheet is (1,1).  The method will try to create the appropriate type of reference based on the
 dimensions of the rectangle.  For example: A rectangle 1 unit wide and 1 unit tall will be translated into a cell reference</remarks>
	<exception cref="T:System.ArgumentException">
		<para>The resulting sheet reference is not within the bounds of its sheet</para>
		<para>The given sheet argument is not registered with the SheetManager</para>
	</exception>
	<example>The following code creates a reference to the range A1:B2 on the currently active sheet
 <code>
 Dim engine As New FormulaEngine
 Dim rect As New Rectangle(1, 1, 2, 2)
 Dim ref As ISheetReference = factory.FromRectangle(rect)
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Cell(System.Int32,System.Int32)">
	<summary>
 Creates a sheet reference to a specific cell on the active sheet
 </summary>
	<param name="row">The row of the cell; first row is 1</param>
	<param name="column">The column of the cell; first column is 1</param>
	<returns>A sheet reference to the specified row and column on the active sheet</returns>
	<remarks>This method behaves exactly like <see cref="M:ciloci.FormulaEngine.ReferenceFactory.Cell(ciloci.FormulaEngine.ISheet,System.Int32,System.Int32)"/>
 except that it uses the currently active sheet</remarks>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Cell(ciloci.FormulaEngine.ISheet,System.Int32,System.Int32)">
	<summary>
 Creates a sheet reference to a cell on a specific sheet
 </summary>
	<param name="sheet">The sheet the reference will be on</param>
	<param name="row">The row of the cell; first row is 1</param>
	<param name="column">The column of the cell; first column is 1</param>
	<returns>A sheet reference to the specified row and column and on the given sheet</returns>
	<remarks>Use this method when you need a sheet reference to a specific cell and sheet and have
 the row and column indices handy.
 You usually need a cell reference when you wish to bind a formula to a cell</remarks>
	<exception cref="T:System.ArgumentException">
		<para>The cell at row,col is not within the bounds of the given sheet</para>
		<para>The given sheet argument is not registered with the SheetManager</para>
	</exception>
	<example>The following code creates a reference to the cell C3 on the currently active sheet
 <code>
 Dim engine As New FormulaEngine
 Dim ref As ISheetReference = engine.ReferenceFactory.Cell(3, 3)
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Cells(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Creates a sheet reference to a range of cells on the currently active sheet
 </summary>
	<param name="startRow">The top of the range</param>
	<param name="startColumn">The left of the range</param>
	<param name="endRow">The right of the range</param>
	<param name="endColumn">The bottom of the range</param>
	<returns>A sheet reference to the specified range on the currently active sheet</returns>
	<remarks>This method behaves exactly like <see cref="M:ciloci.FormulaEngine.ReferenceFactory.Cells(ciloci.FormulaEngine.ISheet,System.Int32,System.Int32,System.Int32,System.Int32)"/>
 except that it uses the currently active sheet</remarks>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Cells(ciloci.FormulaEngine.ISheet,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Creates a sheet reference to a range of cells on a given sheet
 </summary>
	<param name="sheet">The sheet the reference will be on</param>
	<param name="startRow">The top row of the range</param>
	<param name="startColumn">The left column of the range</param>
	<param name="endRow">The bottom row of the range</param>
	<param name="endColumn">The right column of the range</param>
	<returns>A sheet reference to the specified range on the specified sheet</returns>
	<remarks>Use this method when you need a sheet reference to a range of cells on a specific sheet and have the four indices handy.</remarks>
	<exception cref="T:System.ArgumentException">
		<para>The resultant range is not within the bounds of the given sheet</para>
		<para>The given sheet argument is not registered with the SheetManager</para>
	</exception>
	<example>The following example creates a reference to the range C3:E4 on the currently active sheet
 <code>
 Dim engine As New FormulaEngine
 Dim ref As ISheetReference = engine.ReferenceFactory.Cells(3, 3, 4, 5)
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Rows(System.Int32,System.Int32)">
	<summary>
 Creates a reference to a range of rows on the active sheet
 </summary>
	<param name="start">The top row of the range</param>
	<param name="finish">The bottom row of the range</param>
	<returns>A sheet reference to the range of rows on the active sheet</returns>
	<remarks>This method behaves exactly like <see cref="M:ciloci.FormulaEngine.ReferenceFactory.Rows(ciloci.FormulaEngine.ISheet,System.Int32,System.Int32)"/>
 except that it uses the currently active sheet</remarks>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Rows(ciloci.FormulaEngine.ISheet,System.Int32,System.Int32)">
	<summary>
 Creates a reference to a range of rows on a given sheet
 </summary>
	<param name="sheet">The sheet the reference will use</param>
	<param name="start">The top row of the range</param>
	<param name="finish">The bottom row of the range</param>
	<returns>A sheet reference to the range of rows on the given sheet</returns>
	<remarks>This method will create a sheet reference to an entire range of rows on the given sheet.  Use it when
 you wish to reference entire rows and have the two indices handy.</remarks>
	<exception cref="T:System.ArgumentException">
		<para>The resultant range is not within the bounds of the given sheet</para>
		<para>The given sheet argument is not registered with the SheetManager</para>
	</exception>
	<example>The following example creates a reference to rows 5 through 7 on the currently active sheet
 <code>
 Dim engine As New FormulaEngine
 Dim ref As ISheetReference = engine.ReferenceFactory.Rows(5, 7)
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Columns(System.Int32,System.Int32)">
	<summary>
 Creates a reference to a range of columns on the active sheet
 </summary>
	<param name="start">The left column of the range</param>
	<param name="finish">The right column of the range</param>
	<returns>A sheet reference to the range of columns on the given sheet</returns>
	<remarks>This method behaves exactly like <see cref="M:ciloci.FormulaEngine.ReferenceFactory.Columns(ciloci.FormulaEngine.ISheet,System.Int32,System.Int32)"/>
 except that it uses the currently active sheet</remarks>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Columns(ciloci.FormulaEngine.ISheet,System.Int32,System.Int32)">
	<summary>
 Creates a reference to a range of columns on a given sheet
 </summary>
	<param name="sheet">The sheet the reference will use</param>
	<param name="start">The left column of the range</param>
	<param name="finish">The right column of the range</param>
	<returns>A sheet reference to the range of columns on the given sheet</returns>
	<remarks>This method will create a sheet reference to an entire range of columns on the given sheet.  Use it when you
 want to reference entire columns and have the two indices handy.</remarks>
	<exception cref="T:System.ArgumentException">
		<para>The resultant range is not within the bounds of the given sheet</para>
		<para>The given sheet argument is not registered with the SheetManager</para>
	</exception>
	<example>The following example creates a reference to columns A through C on the currently active sheet
 <code>
 Dim engine As New FormulaEngine
 Dim ref As ISheetReference = engine.ReferenceFactory.Columns(1, 3)
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Named(System.String)">
	<summary>
 Creates a named reference
 </summary>
	<param name="name">The name of the reference</param>
	<returns>A reference to the name</returns>
	<remarks>A named reference lets you refer to a formula by a name and lets you refer to that name in other formulas.
 A valid name must start with an underscore or letter and can be followed by any combination of underscores, letters, and numbers.</remarks>
	<exception cref="T:System.ArgumentException">
		<para>The name argument is not in the proper format for a named reference</para>
	</exception>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.External">
	<summary>
 Creates an external reference
 </summary>
	<returns>An external reference</returns>
	<remarks>External references are useful when you need to have many formulas outside of a grid (hence the name) and don't
 want to create unique names for each formula</remarks>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Union(ciloci.FormulaEngine.IReference[])">
	<summary>
 Creates a reference that is a union of a list of references
 </summary>
	<param name="references">The references to union</param>
	<returns>A reference representing the union of the given references</returns>
	<remarks>This method is useful when you need one reference that can represent multiple other references.
 For example: If you want to recalculate cells A1 and B2, you would use this method to get a reference representing both those cells
 and then pass it to the Recalculate method.</remarks>
	<example>This example shows how to create a reference representing the union of cells A1 and B2 and then use that reference
 in one call to the recalculate method:
 <code>
 Dim engine As New FormulaEngine()
 ' Assume we have some formulas that depend on cells A1 and B2
 ' Create references to those cells
 Dim refA1 As IReference = engine.ReferenceFactory.Cell(1, 1)
 Dim refB2 As IReference = engine.ReferenceFactory.Cell(1, 2)
 ' Union them into one reference
 Dim refA1AndA2 As IReference = engine.ReferenceFactory.Union(refA1, refB2)
 ' This single call will recalculate all dependents of A1 and B2
 engine.Recalculate(refA1AndA2)
 </code>
	</example>
</member><member name="M:ciloci.FormulaEngine.ReferenceFactory.Union(ciloci.FormulaEngine.Variable[])">
	<summary>
 Creates a reference that is a union of a list of variables
 </summary>
	<param name="variables">The variables to union</param>
	<returns>A reference representing the union of the given variables</returns>
	<remarks>Works the same way as <see cref="M:ciloci.FormulaEngine.ReferenceFactory.Union(ciloci.FormulaEngine.IReference[])"/>
 except that it works on a list of variables.</remarks>
</member><member name="T:ciloci.FormulaEngine.ReferenceFactory">
	<summary>
 Creates all references used by the formula engine
 </summary>
	<remarks>This class is responsible for creating all references that you will use when interacting with the formula engine.
 It has methods for creating sheet and non-sheet references.  Sheet references can be created from a rectangle, string, or
 integer indices.  There are overloads for creating references to a specific sheet or to the currently active sheet.  Non-grid references
 such as named and external references are also created by this class.
 </remarks>
</member><member name="T:ciloci.FormulaEngine.ExcelConstants">
	<remarks>An enumeration with token and production node
constants.</remarks>
</member><member name="T:ciloci.FormulaEngine.CustomGeneralAnalyzer">
	<summary>
 Processes the parse tree and generates the information necessary to build a formula
 </summary>
</member>
</members>
</doc>